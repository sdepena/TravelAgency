import { Component, Element, Event, Listen, Method, Prop, State, Watch } from "@stencil/core";
import { SelectRender } from "../renders/bootstrap/select/select-render";
export class Select {
    constructor() {
        this.options = [];
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * This attribute lets you specify if the element is disabled.
         * If disabled, it will not fire any user interaction related event
         * (for example, click event).
         */
        this.disabled = false;
        this.renderer = new SelectRender(this);
    }
    getChildOptions() {
        return Array.from(this.element.querySelectorAll("gx-select-option")).map((option) => {
            return {
                disabled: option.disabled,
                innerText: option.innerText,
                selected: option.selected,
                value: option.value
            };
        });
    }
    updateOptions(options) {
        this.options = options;
        this.renderer.updateOptions(options);
    }
    valueChanged() {
        // the select value just changed
        const optionsElement = Array.from(this.element.querySelectorAll("gx-select-option"));
        // let's set the new check state to all options
        // regardless if it is checked or not
        optionsElement.forEach(option => {
            if (option.value === this.value) {
                // the option value matches with the new select value
                // let's check this option
                option.selected = true;
            }
            else {
                // the option value doesn't match
                // with the new select value
                // let's uncheck this option
                option.selected = false;
            }
            // if the new select value doesn't
            // match with any option, all options
            // will be unchecked
        });
        // after set the new check state to all options
        // let's update the options list
        this.updateOptions(optionsElement.map((option) => {
            return {
                disabled: option.disabled,
                innerText: option.innerText,
                selected: option.selected,
                value: option.value
            };
        }));
        if (this.didLoad) {
            // emit the new value
            this.input.emit({ value: this.value });
        }
    }
    onSelectOptionDidLoad(ev) {
        const option = ev.target;
        if (this.value) {
            // check if the select has a setted value
            if (this.value === option.value) {
                // this select has a value and this
                // option equals the correct select value
                // so let's set this option as checked
                option.selected = true;
            }
            else {
                // if the option value does not match
                // with the select value,
                // the option will be unchecked
                // regardless if the option was
                // initialized as checked
                option.selected = false;
            }
        }
        else {
            // if the select does not have a value
            // let's look for options initialized as checked
            if (option.selected) {
                // this option was initialized as checked,
                // so let's set the select's value
                // equals to the checked option value
                this.value = option.value;
            }
            // If there is no option checked
            // and no value was set in the select,
            // it will keep undefined until any
            // change or checked option
        }
        this.updateOptions(this.getChildOptions());
    }
    onSelectOptionDidUnload() {
        this.updateOptions(this.getChildOptions());
    }
    onSelectOptionDisable() {
        this.updateOptions(this.getChildOptions());
    }
    onSelectOptionChange() {
        this.updateOptions(this.getChildOptions());
    }
    onSelectOptionSelect(ev) {
        this.options.forEach(option => {
            if (option === ev.target) {
                if (option.value !== this.value) {
                    this.value = option.value;
                }
            }
            else {
                option.selected = false;
            }
        });
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    async getNativeInputId() {
        return this.renderer.getNativeInputId();
    }
    componentDidLoad() {
        this.didLoad = true;
    }
    render() {
        return this.renderer.render();
    }
    static get is() { return "gx-select"; }
    static get properties() { return {
        "cssClass": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "A CSS class to set as the inner `input` element class."
            },
            "attribute": "css-class",
            "reflect": false
        },
        "invisibleMode": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"collapse\" | \"keep-space\"",
                "resolved": "\"collapse\" | \"keep-space\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute lets you specify how this element will behave when hidden.\n\n| Value        | Details                                                                     |\n| ------------ | --------------------------------------------------------------------------- |\n| `keep-space` | The element remains in the document flow, and it does occupy space.         |\n| `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |"
            },
            "attribute": "invisible-mode",
            "reflect": false,
            "defaultValue": "\"collapse\""
        },
        "disabled": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "false",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute lets you specify if the element is disabled.\nIf disabled, it will not fire any user interaction related event\n(for example, click event)."
            },
            "attribute": "disabled",
            "reflect": false,
            "defaultValue": "false"
        },
        "readonly": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute indicates that the user cannot modify the value of the control.\nSame as [readonly](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-readonly)\nattribute for `input` elements."
            },
            "attribute": "readonly",
            "reflect": false
        },
        "suggest": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Render a text input showing a list of suggested elements."
            },
            "attribute": "suggest",
            "reflect": false
        },
        "placeholder": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Text that appears in the form control when it has no value set"
            },
            "attribute": "placeholder",
            "reflect": false
        },
        "value": {
            "type": "string",
            "mutable": true,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The initial value of the control. Setting the value automatically selects\nthe corresponding option."
            },
            "attribute": "value",
            "reflect": false
        }
    }; }
    static get states() { return {
        "options": {}
    }; }
    static get events() { return [{
            "method": "input",
            "name": "input",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "The `input` event is emitted when a change to the element's value is\ncommitted by the user."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "getNativeInputId": {
            "complexType": {
                "signature": "() => Promise<string>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<string>"
            },
            "docs": {
                "text": "Returns the id of the inner `input` element (if set).",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "element"; }
    static get watchers() { return [{
            "propName": "value",
            "methodName": "valueChanged"
        }]; }
    static get listeners() { return [{
            "name": "gxSelectDidLoad",
            "method": "onSelectOptionDidLoad",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "gxSelectDidUnload",
            "method": "onSelectOptionDidUnload",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "gxDisable",
            "method": "onSelectOptionDisable",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "onChange",
            "method": "onSelectOptionChange",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "gxSelect",
            "method": "onSelectOptionSelect",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
