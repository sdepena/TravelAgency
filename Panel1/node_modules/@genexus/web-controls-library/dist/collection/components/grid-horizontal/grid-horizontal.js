import { Component, Element, Event, Host, Method, Prop, Watch, h } from "@stencil/core";
import { GridBaseHelper } from "../grid-base/grid-base";
import Swiper from "swiper";
export class GridHorizontal {
    constructor() {
        this.swiper = null;
        this.fillMode = "row";
        /**
         * 1-Indexed number of currently active page
         */
        this.currentPage = 1;
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * Logging level. For troubleshooting component update and initialization.
         */
        this.logLevel = "debug";
        /**
         * Set numbers of items to define and enable group sliding. Useful to use with rowsPerPage > 1
         */
        this.itemsPerGroup = 1;
        /**
         * Advanced options to pass to the swiper instance.
         * See http://idangero.us/swiper/api/ for valid options
         */
        this.options = {};
        /**
         * If `true`, show the pagination buttons.
         */
        this.pager = true;
        /**
         * Grid current row count. This property is used in order to be able to re-render the Grid every time the Grid data changes.
         * If not specified, then grid empty and loading placeholders will not work correctly.
         */
        this.recordCount = null;
        /**
         * If `true`, show the scrollbar.
         */
        this.scrollbar = false;
        /**
         * Set to false to enable slides in free mode position.
         */
        this.snapToGrid = true;
        /**
         * True to highlight control when an action is fired.
         */
        this.highlightable = false;
    }
    getSwiperCurrentPage() {
        return this.currentPage - 1;
    }
    pageChanged() {
        if (this.isInitialized()) {
            this.swiper.slideTo(Math.floor(this.getSwiperCurrentPage() * this.itemsPerGroup));
        }
    }
    optionsChanged() {
        if (this.isInitialized()) {
            Object.assign(this.swiper.params, this.options);
        }
    }
    componentDidLoad() {
        window.requestAnimationFrame(() => this.ensureSwiper());
        GridBaseHelper.init(this);
    }
    componentDidUpdate() {
        this.update();
    }
    componentDidUnload() {
        if (this.isInitialized()) {
            this.swiper.destroy(true, true);
        }
    }
    /**
     * Update the underlying slider implementation. Call this if you've added or removed
     * child slides.
     */
    async update() {
        if (this.loadingState !== "loading") {
            if (this.isInitialized()) {
                this.log("Updating Swiper..");
                this.swiper.update();
            }
            else {
                window.requestAnimationFrame(() => this.ensureSwiper());
            }
        }
    }
    /**
     * Force swiper to update its height (when autoHeight is enabled) for the duration
     * equal to 'speed' parameter.
     *
     * @param speed The transition duration (in ms).
     */
    async updateAutoHeight(speed) {
        this.swiper.updateAutoHeight(speed);
    }
    /**
     * Transition to the specified slide.
     *
     * @param index The index of the slide to transition to.
     * @param speed The transition duration (in ms).
     * @param runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.
     */
    async slideTo(index, speed, runCallbacks) {
        this.swiper.slideTo(index, speed, runCallbacks);
    }
    /**
     * Transition to the next slide.
     *
     * @param speed The transition duration (in ms).
     * @param runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.
     */
    async slideNext(speed, runCallbacks) {
        this.swiper.slideNext(speed, runCallbacks);
    }
    /**
     * Transition to the previous slide.
     *
     * @param speed The transition duration (in ms).
     * @param runCallbacks If true, the transition will produce the [Transition/SlideChange][Start/End] transition events.
     */
    async slidePrev(speed, runCallbacks) {
        this.swiper.slidePrev(speed, runCallbacks);
    }
    /**
     * Get the index of the current active slide.
     */
    async getActiveIndex() {
        return this.swiper.activeIndex;
    }
    /**
     * Get the index of the previous slide.
     */
    async getPreviousIndex() {
        return this.swiper.previousIndex;
    }
    /**
     * Get the total number of slides.
     */
    async length() {
        return this.swiper.slides.length;
    }
    /**
     * Get whether or not the current slide is the last slide.
     */
    async isLast() {
        return this.swiper.isEnd;
    }
    /**
     * Get whether or not the current slide is the first slide.
     */
    async isStart() {
        return this.swiper.isBeginning;
    }
    /**
     * Start auto play.
     */
    async startAutoplay() {
        if (this.swiper.autoplay !== null) {
            this.swiper.autoplay.start();
        }
    }
    /**
     * Stop auto play.
     */
    async stopAutoplay() {
        if (this.swiper.autoplay !== null) {
            this.swiper.autoplay.stop();
        }
    }
    /**
     * Lock or unlock the ability to slide to the next slide.
     *
     * @param lock If `true`, disable swiping to the next slide.
     */
    async toggleLockSwipeToNext(lock) {
        this.swiper.allowSlideNext = !lock;
    }
    /**
     * Lock or unlock the ability to slide to the previous slide.
     *
     * @param lock If `true`, disable swiping to the previous slide.
     */
    async toggleLockSwipeToPrev(lock) {
        this.swiper.allowSlidePrev = !lock;
    }
    /**
     * Lock or unlock the ability to slide to the next or previous slide.
     *
     * @param lock If `true`, disable swiping to the next and previous slide.
     */
    async toggleLockSwipes(lock) {
        this.swiper.allowSlideNext = !lock;
        this.swiper.allowSlidePrev = !lock;
        this.swiper.allowTouchMove = !lock;
    }
    ensureSwiper() {
        if (this.swiper === null &&
            this.recordCount > 0 &&
            this.loadingState !== "loading") {
            const opts = this.normalizeOptions();
            const container = this.element;
            container
                .querySelector("[slot='grid-content']")
                .classList.add("swiper-wrapper");
            this.log("Initializing Swiper..");
            this.swiper = new Swiper(container, opts);
        }
        return this.isInitialized();
    }
    isInitialized() {
        return this.swiper !== null;
    }
    log(msg) {
        if (msg && this.logLevel !== "off") {
            // console.log(msg, this.recordCount, this.loadingState, this.el);
        }
    }
    optionValueDefault(value, defaultValue) {
        return value || defaultValue;
    }
    normalizeOptions() {
        const swiperOptions = {
            autoHeight: false,
            autoplay: false,
            centeredSlides: false,
            direction: this.optionValueDefault(this.direction, "horizontal"),
            effect: undefined,
            freeMode: !this.snapToGrid,
            freeModeMomentum: false,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeMomentumVelocityRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            initialSlide: this.getSwiperCurrentPage() * this.itemsPerGroup,
            loop: false,
            parallax: false,
            setWrapperSize: false,
            slidesOffsetAfter: 0,
            slidesOffsetBefore: 0,
            slidesPerColumn: this.optionValueDefault(this.rows, 1),
            slidesPerColumnFill: this.fillMode,
            slidesPerGroup: this.optionValueDefault(this.itemsPerGroup, 1),
            slidesPerView: this.optionValueDefault(this.columns, 1),
            spaceBetween: 0,
            speed: 300,
            touchEventsTarget: "container",
            zoom: {
                maxRatio: 3,
                minRatio: 1,
                toggle: true
            },
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            threshold: 0,
            touchMoveStopPropagation: true,
            touchReleaseOnEdges: false,
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            mousewheel: false,
            resistance: true,
            resistanceRatio: 0.85,
            roundLengths: true,
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            watchOverflow: this.pager,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loopAdditionalSlides: 0,
            noSwiping: true,
            runCallbacksOnInit: true,
            coverflowEffect: {
                depth: 100,
                modifier: 1,
                rotate: 50,
                slideShadows: true,
                stretch: 0
            },
            flipEffect: {
                limitRotation: true,
                slideShadows: true
            },
            cubeEffect: {
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94,
                slideShadows: true
            },
            fadeEffect: {
                crossFade: false
            }
        };
        if (this.pager) {
            swiperOptions.pagination = {
                clickable: false,
                el: this.paginationEl,
                hideOnClick: false,
                type: "bullets"
            };
        }
        if (this.scrollbar) {
            swiperOptions.scrollbar = {
                el: this.scrollbarEl,
                hide: true
            };
        }
        const eventOptions = {
            on: {
                doubleTap: this.gxGridDoubleClick.emit,
                init: () => {
                    setTimeout(() => {
                        this.gxGridDidLoad.emit();
                    }, 20);
                },
                reachBeginning: this.gxGridReachStart.emit,
                reachEnd: () => {
                    this.log("reachEnd");
                    this.gxGridReachEnd.emit();
                    this.gxInfiniteThresholdReached.emit();
                },
                slideChangeTransitionEnd: () => {
                    if (this.swiper !== null) {
                        this.log("pageChanged");
                        const currentPage = Math.ceil(this.swiper.activeIndex / this.itemsPerGroup);
                        this.gxGridDidChange.emit(currentPage + 1);
                    }
                },
                slideChangeTransitionStart: this.gxGridWillChange.emit,
                slideNextTransitionStart: this.gxGridNextStart.emit,
                slidePrevTransitionStart: this.gxGridPrevStart.emit,
                slideNextTransitionEnd: this.gxGridNextEnd.emit,
                slidePrevTransitionEnd: this.gxGridPrevEnd.emit,
                sliderMove: this.gxGridDrag.emit,
                transitionStart: this.gxGridTransitionStart.emit,
                transitionEnd: this.gxGridTransitionEnd.emit,
                touchStart: this.gxGridTouchStart.emit,
                touchEnd: this.gxGridTouchEnd.emit,
                tap: this.gxGridClick.emit
            }
        };
        const customEvents = this.options.on || {};
        // merge "on" event listeners, while giving our event listeners priority
        const mergedEventOptions = { on: Object.assign(Object.assign({}, customEvents), eventOptions.on) };
        // Merge the base, user options, and events together then pass to swiper
        return Object.assign(Object.assign(Object.assign({}, swiperOptions), this.options), mergedEventOptions);
    }
    getViewPortHeightIfColumnFill() {
        let height = null;
        if (this.autoGrow || this.fillMode === "row") {
            return height;
        }
        //When 'column' it uses flex-direction: column layout which requires specified height on swiper-container.
        height = this.element.parentElement.offsetHeight;
    }
    render() {
        const height = this.getViewPortHeightIfColumnFill();
        const hostData = GridBaseHelper.hostData(this);
        hostData.class = Object.assign(Object.assign({}, hostData.class), {
            "swiper-container": true
        });
        return (h(Host, Object.assign({}, hostData, { style: {
                height: height
            } }), [
            h("slot", { name: "grid-content" }),
            this.pager && (h("div", { class: "gx-grid-paging swiper-pagination", ref: el => (this.paginationEl = el) })),
            this.scrollbar && (h("div", { class: "swiper-scrollbar", ref: el => (this.scrollbarEl = el) })),
            h("slot", { name: "grid-empty-loading-placeholder" }),
            h("div", { class: "grid-empty-placeholder" },
                h("slot", { name: "grid-content-empty" })),
            h("slot", null)
        ]));
    }
    static get is() { return "gx-grid-horizontal"; }
    static get originalStyleUrls() { return {
        "$": ["grid-horizontal.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["grid-horizontal.css"]
    }; }
    static get properties() { return {
        "autoGrow": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute defines if the control size will grow automatically,\nto adjust to its content size.\nIf set to `false`, it won't grow automatically and it will show scrollbars\nif the content overflows."
            },
            "attribute": "auto-grow",
            "reflect": false
        },
        "columns": {
            "type": "any",
            "mutable": false,
            "complexType": {
                "original": "number | \"auto\"",
                "resolved": "\"auto\" | number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Number of items per column (items visible at the same time on slider's container)."
            },
            "attribute": "columns",
            "reflect": false
        },
        "currentPage": {
            "type": "number",
            "mutable": true,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "1-Indexed number of currently active page"
            },
            "attribute": "current-page",
            "reflect": false,
            "defaultValue": "1"
        },
        "invisibleMode": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"collapse\" | \"keep-space\"",
                "resolved": "\"collapse\" | \"keep-space\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute lets you specify how this element will behave when hidden.\n\n| Value        | Details                                                                     |\n| ------------ | --------------------------------------------------------------------------- |\n| `keep-space` | The element remains in the document flow, and it does occupy space.         |\n| `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |"
            },
            "attribute": "invisible-mode",
            "reflect": false,
            "defaultValue": "\"collapse\""
        },
        "loadingState": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"loading\" | \"loaded\"",
                "resolved": "\"loaded\" | \"loading\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Grid loading state. It's purpose is to know whether the grid loading animation or the grid empty placeholder should be shown.\n\n| Value        | Details                                                                                        |\n| ------------ | ---------------------------------------------------------------------------------------------- |\n| `loading` | The grid is waiting the server for the grid data. Grid loading mask will be shown.                |\n| `loaded`   | The grid data has been loaded. If the grid has no records, the empty place holder will be shown. |"
            },
            "attribute": "loading-state",
            "reflect": false
        },
        "logLevel": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"debug\" | \"off\"",
                "resolved": "\"debug\" | \"off\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Logging level. For troubleshooting component update and initialization."
            },
            "attribute": "log-level",
            "reflect": false,
            "defaultValue": "\"debug\""
        },
        "itemsPerGroup": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "1",
                "resolved": "1",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Set numbers of items to define and enable group sliding. Useful to use with rowsPerPage > 1"
            },
            "attribute": "items-per-group",
            "reflect": false,
            "defaultValue": "1"
        },
        "direction": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"horizontal\" | \"vertical\"",
                "resolved": "\"horizontal\" | \"vertical\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Items layout direction: Could be 'horizontal' or 'vertical' (for vertical slider)."
            },
            "attribute": "direction",
            "reflect": false
        },
        "options": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "SwiperOptions",
                "resolved": "SwiperOptions",
                "references": {
                    "SwiperOptions": {
                        "location": "import",
                        "path": "swiper"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Advanced options to pass to the swiper instance.\nSee http://idangero.us/swiper/api/ for valid options"
            },
            "defaultValue": "{}"
        },
        "pager": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "true",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "If `true`, show the pagination buttons."
            },
            "attribute": "pager",
            "reflect": false,
            "defaultValue": "true"
        },
        "recordCount": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Grid current row count. This property is used in order to be able to re-render the Grid every time the Grid data changes.\nIf not specified, then grid empty and loading placeholders will not work correctly."
            },
            "attribute": "record-count",
            "reflect": false,
            "defaultValue": "null"
        },
        "rows": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Number of items per column, for multirow layout."
            },
            "attribute": "rows",
            "reflect": false
        },
        "scrollbar": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "false",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "If `true`, show the scrollbar."
            },
            "attribute": "scrollbar",
            "reflect": false,
            "defaultValue": "false"
        },
        "snapToGrid": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "true",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Set to false to enable slides in free mode position."
            },
            "attribute": "snap-to-grid",
            "reflect": false,
            "defaultValue": "true"
        },
        "highlightable": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "false",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "True to highlight control when an action is fired."
            },
            "attribute": "highlightable",
            "reflect": false,
            "defaultValue": "false"
        }
    }; }
    static get events() { return [{
            "method": "gxInfiniteThresholdReached",
            "name": "gxInfiniteThresholdReached",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "This Handler will be called every time grid threshold is reached. Needed for infinite scrolling grids."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridDidLoad",
            "name": "gxGridDidLoad",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted after Swiper initialization"
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridClick",
            "name": "gxGridClick",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the user taps/clicks on the slide's container."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridDoubleClick",
            "name": "gxGridDoubleClick",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the user double taps on the slide's container."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridWillChange",
            "name": "gxGridWillChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted before the active slide has changed."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridDidChange",
            "name": "gxGridDidChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted after the active slide has changed."
            },
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            }
        }, {
            "method": "gxGridNextStart",
            "name": "gxGridNextStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the next slide has started."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridPrevStart",
            "name": "gxGridPrevStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the previous slide has started."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridNextEnd",
            "name": "gxGridNextEnd",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the next slide has ended."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridPrevEnd",
            "name": "gxGridPrevEnd",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the previous slide has ended."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridTransitionStart",
            "name": "gxGridTransitionStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the slide transition has started."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridTransitionEnd",
            "name": "gxGridTransitionEnd",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the slide transition has ended."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridDrag",
            "name": "gxGridDrag",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the slider is actively being moved."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridReachStart",
            "name": "gxGridReachStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the slider is at its initial position."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridReachEnd",
            "name": "gxGridReachEnd",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the slider is at the last slide."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridTouchStart",
            "name": "gxGridTouchStart",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the user first touches the slider."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "gxGridTouchEnd",
            "name": "gxGridTouchEnd",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the user releases the touch."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "update": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Update the underlying slider implementation. Call this if you've added or removed\nchild slides.",
                "tags": []
            }
        },
        "updateAutoHeight": {
            "complexType": {
                "signature": "(speed?: number) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "speed The transition duration (in ms).",
                                "name": "param"
                            }],
                        "text": "The transition duration (in ms)."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Force swiper to update its height (when autoHeight is enabled) for the duration\nequal to 'speed' parameter.",
                "tags": [{
                        "name": "param",
                        "text": "speed The transition duration (in ms)."
                    }]
            }
        },
        "slideTo": {
            "complexType": {
                "signature": "(index: number, speed?: number, runCallbacks?: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "index The index of the slide to transition to.",
                                "name": "param"
                            }],
                        "text": "The index of the slide to transition to."
                    }, {
                        "tags": [{
                                "text": "speed The transition duration (in ms).",
                                "name": "param"
                            }],
                        "text": "The transition duration (in ms)."
                    }, {
                        "tags": [{
                                "text": "runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.",
                                "name": "param"
                            }],
                        "text": "If true, the transition will produce [Transition/SlideChange][Start/End] transition events."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Transition to the specified slide.",
                "tags": [{
                        "name": "param",
                        "text": "index The index of the slide to transition to."
                    }, {
                        "name": "param",
                        "text": "speed The transition duration (in ms)."
                    }, {
                        "name": "param",
                        "text": "runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events."
                    }]
            }
        },
        "slideNext": {
            "complexType": {
                "signature": "(speed?: number, runCallbacks?: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "speed The transition duration (in ms).",
                                "name": "param"
                            }],
                        "text": "The transition duration (in ms)."
                    }, {
                        "tags": [{
                                "text": "runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.",
                                "name": "param"
                            }],
                        "text": "If true, the transition will produce [Transition/SlideChange][Start/End] transition events."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Transition to the next slide.",
                "tags": [{
                        "name": "param",
                        "text": "speed The transition duration (in ms)."
                    }, {
                        "name": "param",
                        "text": "runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events."
                    }]
            }
        },
        "slidePrev": {
            "complexType": {
                "signature": "(speed?: number, runCallbacks?: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "speed The transition duration (in ms).",
                                "name": "param"
                            }],
                        "text": "The transition duration (in ms)."
                    }, {
                        "tags": [{
                                "text": "runCallbacks If true, the transition will produce the [Transition/SlideChange][Start/End] transition events.",
                                "name": "param"
                            }],
                        "text": "If true, the transition will produce the [Transition/SlideChange][Start/End] transition events."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Transition to the previous slide.",
                "tags": [{
                        "name": "param",
                        "text": "speed The transition duration (in ms)."
                    }, {
                        "name": "param",
                        "text": "runCallbacks If true, the transition will produce the [Transition/SlideChange][Start/End] transition events."
                    }]
            }
        },
        "getActiveIndex": {
            "complexType": {
                "signature": "() => Promise<number>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<number>"
            },
            "docs": {
                "text": "Get the index of the current active slide.",
                "tags": []
            }
        },
        "getPreviousIndex": {
            "complexType": {
                "signature": "() => Promise<number>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<number>"
            },
            "docs": {
                "text": "Get the index of the previous slide.",
                "tags": []
            }
        },
        "length": {
            "complexType": {
                "signature": "() => Promise<number>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<number>"
            },
            "docs": {
                "text": "Get the total number of slides.",
                "tags": []
            }
        },
        "isLast": {
            "complexType": {
                "signature": "() => Promise<boolean>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<boolean>"
            },
            "docs": {
                "text": "Get whether or not the current slide is the last slide.",
                "tags": []
            }
        },
        "isStart": {
            "complexType": {
                "signature": "() => Promise<boolean>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<boolean>"
            },
            "docs": {
                "text": "Get whether or not the current slide is the first slide.",
                "tags": []
            }
        },
        "startAutoplay": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Start auto play.",
                "tags": []
            }
        },
        "stopAutoplay": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Stop auto play.",
                "tags": []
            }
        },
        "toggleLockSwipeToNext": {
            "complexType": {
                "signature": "(lock: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "lock If `true`, disable swiping to the next slide.",
                                "name": "param"
                            }],
                        "text": "If `true`, disable swiping to the next slide."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Lock or unlock the ability to slide to the next slide.",
                "tags": [{
                        "name": "param",
                        "text": "lock If `true`, disable swiping to the next slide."
                    }]
            }
        },
        "toggleLockSwipeToPrev": {
            "complexType": {
                "signature": "(lock: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "lock If `true`, disable swiping to the previous slide.",
                                "name": "param"
                            }],
                        "text": "If `true`, disable swiping to the previous slide."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Lock or unlock the ability to slide to the previous slide.",
                "tags": [{
                        "name": "param",
                        "text": "lock If `true`, disable swiping to the previous slide."
                    }]
            }
        },
        "toggleLockSwipes": {
            "complexType": {
                "signature": "(lock: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "lock If `true`, disable swiping to the next and previous slide.",
                                "name": "param"
                            }],
                        "text": "If `true`, disable swiping to the next and previous slide."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Lock or unlock the ability to slide to the next or previous slide.",
                "tags": [{
                        "name": "param",
                        "text": "lock If `true`, disable swiping to the next and previous slide."
                    }]
            }
        }
    }; }
    static get elementRef() { return "element"; }
    static get watchers() { return [{
            "propName": "currentPage",
            "methodName": "pageChanged"
        }, {
            "propName": "options",
            "methodName": "optionsChanged"
        }]; }
}
