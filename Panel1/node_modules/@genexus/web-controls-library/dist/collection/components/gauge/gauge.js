import { Component, Element, Event, Host, Listen, Prop, State, h } from "@stencil/core";
export class Gauge {
    constructor() {
        /**
         * This property allows selecting the gauge type. The allowed values are `circle` or `line` (defautl).
         */
        this.type = "line";
        /**
         *  Set `true` to display the current value. Default is `false`.
         *
         */
        this.showValue = false;
        /**
         *  Set `true` to display the minimum and maximum value. Default is `false`.
         *
         */
        this.showMinMax = false;
        /**
         * The minimum value of the gauge
         * 0 by Default
         */
        this.minValue = 0;
        /**
         * Allows specify the width of the circumference _(When gauge is circle type)_ or the width of the bar _(When gauge is Line type)_ in % relative the component size.
         *
         */
        this.thickness = 10;
        this.rangesChildren = [];
        this.maxValueAux = this.minValue;
        this.totalAmount = 0;
    }
    onGaugeRangeDidLoad({ detail: childRange }) {
        this.rangesChildren = [...this.rangesChildren, childRange];
        this.totalAmount += childRange.amount;
        // Possible improvement here. Check the approach applied in navbar.jsx line 103
        childRange.element.addEventListener("gxGaugeRangeDidUnload", () => {
            this.rangesChildren = this.rangesChildren.filter(elementToSave => elementToSave != childRange);
            this.totalAmount -= childRange.amount;
        });
        childRange.element.addEventListener("gxGaugeRangeDidUpdate", () => {
            const index = this.rangesChildren.findIndex(elementFinding => elementFinding === childRange);
            this.rangesChildren.splice(index, 1, childRange);
            this.totalAmount = 0;
            for (const childInstance of this.rangesChildren) {
                this.totalAmount += childInstance.amount;
            }
        });
    }
    // If maxValue is undefined, it defines the maxValue as the sum of the amounts plus minValue
    updateMaxValueAux() {
        this.maxValueAux =
            this.maxValue === undefined
                ? this.minValue + this.totalAmount
                : this.maxValue;
    }
    calcThickness() {
        return typeof this.thickness === "number" &&
            this.thickness > 0 &&
            this.thickness <= 100
            ? this.thickness / 5
            : 10;
    }
    calcPercentage() {
        return this.value <= this.minValue
            ? 0
            : ((this.value - this.minValue) * 100) /
                (this.maxValueAux - this.minValue);
    }
    addCircleRanges({ amount, color }, position, radius) {
        const FULL_CIRCLE_RADIANS = 2 * Math.PI;
        const ROTATION_FIX = -90;
        const circleLength = FULL_CIRCLE_RADIANS * radius;
        const range = this.maxValueAux - this.minValue;
        const valuePercentage = amount / range;
        return (h("circle", { class: "circle-range", r: radius, cx: "50%", cy: "50%", stroke: color, "stroke-dasharray": `${circleLength * valuePercentage}, ${circleLength}`, fill: "none", transform: `rotate(${position + ROTATION_FIX} 50,50)`, "data-amount": amount, "stroke-width": `${this.thickness}%` }));
    }
    addLineRanges({ amount, color }, position) {
        const range = this.maxValueAux - this.minValue;
        return (h("div", { class: "range", style: {
                "background-color": color,
                "margin-left": `${position}%`,
                width: `${(amount * 100) / range}%`
            } }));
    }
    addLineRangesLabels({ amount, color, name }, position) {
        const range = this.maxValueAux - this.minValue;
        return (h("span", { class: "rangeName", style: {
                "margin-left": `${position}%`,
                color: color,
                // transform: `translateY(-${this.thickness >= 7 ? 0 : 12 + this.thickness}px)`,
                transform: `translateY(${this.thickness >= 7
                    ? 0
                    : this.element.offsetHeight / 4 + this.thickness / 3}px)`,
                width: `${(amount * 100) / range}%`
            } }, name));
    }
    renderCircle(childRanges) {
        const FULL_CIRCLE_RADIO = 100 / 2;
        const svgRanges = [];
        const ONE_PERCENT_OF_CIRCLE_DREGREE = 3.6;
        const radius = FULL_CIRCLE_RADIO - this.thickness / 2;
        const ROTATION_FIX = 90; // Used to correct the rotation
        this.totalAmount = 0;
        for (let i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        const range = this.maxValueAux - this.minValue;
        let positionInGauge = 0;
        for (let i = 0; i < childRanges.length; i++) {
            svgRanges.push(this.addCircleRanges(childRanges[i], positionInGauge, radius));
            positionInGauge += (360 * childRanges[i].amount) / range;
        }
        const rotation = this.calcPercentage() == 100
            ? `rotate(${359.5 + ROTATION_FIX}deg)`
            : `rotate(${this.calcPercentage() * ONE_PERCENT_OF_CIRCLE_DREGREE +
                ROTATION_FIX}deg)`;
        if (this.showValue) {
            const ro = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const elem = entry.contentRect;
                    const minimumSize = Math.min(elem.width, elem.height);
                    const value = this.element.querySelector(".current-value");
                    const marker = this.element.querySelector(".circularMarker");
                    const markerIndicator = this.element.querySelector(".circularIndicator");
                    value.setAttribute("style", `font-size: ${minimumSize / 2.5}px`);
                    marker.setAttribute("style", `transform: ${rotation}; max-width: ${minimumSize}px`);
                    markerIndicator.setAttribute("style", `width: ${this.thickness + 2}%; height: ${minimumSize / 100}px`);
                }
            });
            // Observe the gauge to resize the font and the value marker
            ro.observe(this.element);
        }
        return (h(Host, null,
            h("div", { class: "svgContainer" },
                h("svg", { viewBox: "0 0 100 100" },
                    h("circle", { r: radius, cx: "50%", cy: "50%", stroke: "rgba(0, 0, 0, 0.2)", fill: "none", "stroke-width": `${this.thickness / 2}%` }),
                    svgRanges),
                this.showValue && (h("div", { class: "gauge" },
                    h("div", null, this.showValue && (h("span", { class: "current-value" }, `${this.value}`)))))),
            this.showValue && (h("div", { class: "circularMarker" },
                h("div", { class: "circularIndicator" })))));
    }
    renderLine(childRanges) {
        const divRanges = [];
        const divRangesName = [];
        this.totalAmount = 0;
        for (let i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        // Depending of `this.value`, it calculates how much the value marker has to move from the left side
        const valueOffset = this.value <= this.minValue
            ? 0
            : this.value >= this.maxValueAux
                ? 100
                : this.calcPercentage() >= 98
                    ? 72
                    : 50;
        const range = this.maxValueAux - this.minValue;
        let positionInGauge = 0;
        for (let i = 0; i < childRanges.length; i++) {
            divRanges.push(this.addLineRanges(childRanges[i], positionInGauge));
            divRangesName.push(this.addLineRangesLabels(childRanges[i], positionInGauge));
            positionInGauge += (100 * childRanges[i].amount) / range;
        }
        return (h("div", { class: "gaugeContainerLine", style: {
                height: `${10 * this.calcThickness()}px`,
                "margin-top": `${this.showValue || this.thickness < 7 ? 23.5 : 0}px`,
                "margin-bottom": `${this.showValue && this.thickness < 7 ? 22 : this.showMinMax ? 20 : 1}px`
            } },
            h("div", { class: "gauge" }, this.showValue ? (h("span", { class: "marker", style: {
                    "margin-left": `${this.value <= this.minValue
                        ? 0
                        : this.value >= this.maxValueAux
                            ? 100
                            : this.calcPercentage()}%`,
                    transform: `translate(-${valueOffset}%, -28px)` // 22px, 38px
                } }, this.value)) : ("")),
            h("div", { class: "rangesContainer", style: {
                    height: `${2 * this.thickness}px`,
                    "border-radius": `${this.thickness}px`
                } }, divRanges),
            this.showValue ? (h("span", { class: "marker", style: {
                    "margin-left": `${this.calcPercentage() >= 100 ? 100 : this.calcPercentage()}%`
                } },
                h("div", { class: "indicator", style: {
                        height: `${this.thickness * 2 + 4}px`,
                        "border-left-width": `${this.element.offsetWidth /
                            document.body.offsetWidth}vw`,
                        transform: this.calcPercentage() > 0 && this.calcPercentage() < 100
                            ? "translateX(-50%)"
                            : this.calcPercentage() >= 100
                                ? "translateX(-100%)"
                                : "translateX(0%)"
                    } }))) : (""),
            h("div", { class: "labelsContainerLine" }, divRangesName),
            this.showMinMax ? (h("div", { class: "minMaxDisplay" },
                h("span", { class: "minValue" },
                    this.minValue,
                    h("span", null)),
                h("span", { class: "maxValue" },
                    this.maxValueAux,
                    h("span", null)))) : ("")));
    }
    render() {
        this.minimumSize =
            this.element.offsetHeight > this.element.offsetWidth
                ? this.element.offsetWidth
                : this.element.offsetHeight;
        const childRanges = Array.from(this.element.querySelectorAll("gx-gauge-range"));
        if (this.type === "circle") {
            return this.renderCircle(childRanges);
        }
        else if (this.type === "line") {
            return this.renderLine(childRanges);
        }
        else {
            // tslint:disable-next-line:no-console
            console.warn("Error rendering component. Invalid type of gauge in ", this.element);
        }
    }
    static get is() { return "gx-gauge"; }
    static get originalStyleUrls() { return {
        "$": ["gauge.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["gauge.css"]
    }; }
    static get properties() { return {
        "type": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"line\" | \"circle\"",
                "resolved": "\"circle\" | \"line\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This property allows selecting the gauge type. The allowed values are `circle` or `line` (defautl)."
            },
            "attribute": "type",
            "reflect": false,
            "defaultValue": "\"line\""
        },
        "showValue": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Set `true` to display the current value. Default is `false`."
            },
            "attribute": "show-value",
            "reflect": false,
            "defaultValue": "false"
        },
        "showMinMax": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Set `true` to display the minimum and maximum value. Default is `false`."
            },
            "attribute": "show-min-max",
            "reflect": false,
            "defaultValue": "false"
        },
        "minValue": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The minimum value of the gauge\n0 by Default"
            },
            "attribute": "min-value",
            "reflect": false,
            "defaultValue": "0"
        },
        "value": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The current value of the gauge"
            },
            "attribute": "value",
            "reflect": false
        },
        "thickness": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Allows specify the width of the circumference _(When gauge is circle type)_ or the width of the bar _(When gauge is Line type)_ in % relative the component size."
            },
            "attribute": "thickness",
            "reflect": false,
            "defaultValue": "10"
        },
        "maxValue": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The maximum value of the gauge.\nThis prop allows specify the maximum value that the gauge will handle. If there is no value specified it will be calculated by the sum of all gx-ranges values"
            },
            "attribute": "max-value",
            "reflect": false
        }
    }; }
    static get states() { return {
        "rangesChildren": {}
    }; }
    static get events() { return [{
            "method": "gxGaugeDidLoad",
            "name": "gxGaugeDidLoad",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "The `gxGaugeDidLoad` event is triggered when the component has been rendered completely."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }]; }
    static get elementRef() { return "element"; }
    static get listeners() { return [{
            "name": "gxGaugeRangeDidLoad",
            "method": "onGaugeRangeDidLoad",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
