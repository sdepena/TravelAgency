import { Component, Element, Event, Method, Prop, State, Watch, h } from "@stencil/core";
import { TimerState } from "./chronometer-timer-state";
export class Chronometer {
    constructor() {
        this.startedTime = 0;
        this.started = false;
        this.elapsedTime = 0;
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * When the chronometer reaches this value,
         * MaxValueText will be shown instead of the Chronometer value.
         */
        this.maxValue = 0;
        /**
         * Time unit: (s) seconds or (ms) milliseconds for every time control Property.
         */
        this.unit = "s";
        /**
         * Defines the interval that the function onTick will be called.
         */
        this.interval = 1;
        /**
         * State of the Chronometer.
         */
        this.state = TimerState.Stopped;
        /**
         * The value of the control.
         */
        this.value = 0;
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    async getNativeInputId() {
        return this.element;
    }
    componentWillLoad() {
        this.elapsedTime = this.value * this.getUnit();
    }
    componentDidUnload() {
        this.stop();
    }
    /**
     * Starts the Chronometer
     */
    async start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.startedTime = Date.now() - this.elapsedTime;
        this.updateElapsedTime();
        this.timer = window.setInterval(() => {
            this.updateElapsedTime();
            if (this.maxValue > 0 &&
                this.elapsedTime >= this.maxValue * this.getUnit()) {
                this.end.emit();
                this.stop();
            }
        }, 1000);
        if (this.interval > 0) {
            this.eventTimer = window.setInterval(() => {
                this.tickHandler();
            }, this.interval * this.getUnit());
        }
    }
    /**
     * Stops the Chronometer
     */
    async stop() {
        window.clearInterval(this.eventTimer);
        window.clearInterval(this.timer);
        this.started = false;
        this.startedTime = 0;
    }
    /**
     * Stops and set to 0 the Chronometer.
     */
    async reset() {
        this.stop();
        this.value = 0;
        this.startedTime = 0;
        this.elapsedTime = 0;
    }
    handleChange() {
        this.input.emit();
        this.change.emit();
    }
    tickHandler() {
        this.tick.emit();
    }
    stateChanged(newState, oldState) {
        if (oldState === newState) {
            return;
        }
        switch (newState) {
            case TimerState.Running:
                this.start();
                break;
            case TimerState.Stopped:
                this.stop();
                break;
            case TimerState.Reset:
                this.reset();
                break;
            default:
                break;
        }
    }
    getUnit() {
        return this.unit === "s" ? 1000 : 1;
    }
    updateElapsedTime() {
        this.elapsedTime = Date.now() - this.startedTime;
        this.value = Math.floor(this.elapsedTime / this.getUnit());
    }
    render() {
        const time = Math.floor(this.elapsedTime / 1000);
        const maxVal = this.maxValue * this.getUnit();
        const maxValueReached = this.elapsedTime > maxVal && maxVal !== 0;
        return h("span", null, maxValueReached ? this.maxValueText : time);
    }
    static get is() { return "gx-chronometer"; }
    static get originalStyleUrls() { return {
        "$": ["chronometer.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["chronometer.css"]
    }; }
    static get properties() { return {
        "invisibleMode": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"collapse\" | \"keep-space\"",
                "resolved": "\"collapse\" | \"keep-space\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute lets you specify how this element will behave when hidden.\n\n| Value        | Details                                                                     |\n| ------------ | --------------------------------------------------------------------------- |\n| `keep-space` | The element remains in the document flow, and it does occupy space.         |\n| `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |"
            },
            "attribute": "invisible-mode",
            "reflect": false,
            "defaultValue": "\"collapse\""
        },
        "maxValue": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "0",
                "resolved": "0",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "When the chronometer reaches this value,\nMaxValueText will be shown instead of the Chronometer value."
            },
            "attribute": "max-value",
            "reflect": false,
            "defaultValue": "0"
        },
        "maxValueText": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Text to be displayed when chronometer value reaches maxValue."
            },
            "attribute": "max-value-text",
            "reflect": false
        },
        "unit": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"s\" | \"ms\"",
                "resolved": "\"ms\" | \"s\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Time unit: (s) seconds or (ms) milliseconds for every time control Property."
            },
            "attribute": "unit",
            "reflect": false,
            "defaultValue": "\"s\""
        },
        "interval": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "1",
                "resolved": "1",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Defines the interval that the function onTick will be called."
            },
            "attribute": "interval",
            "reflect": false,
            "defaultValue": "1"
        },
        "state": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "TimerState",
                "resolved": "TimerState.Reset | TimerState.Running | TimerState.Stopped",
                "references": {
                    "TimerState": {
                        "location": "import",
                        "path": "./chronometer-timer-state"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "State of the Chronometer."
            },
            "attribute": "state",
            "reflect": false,
            "defaultValue": "TimerState.Stopped"
        },
        "value": {
            "type": "number",
            "mutable": true,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The value of the control."
            },
            "attribute": "value",
            "reflect": false,
            "defaultValue": "0"
        }
    }; }
    static get states() { return {
        "elapsedTime": {}
    }; }
    static get events() { return [{
            "method": "input",
            "name": "input",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "The `input` event is emitted every time the chronometer changes (every 1 second)"
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "change",
            "name": "change",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "The `change` event is emitted every time the chronometer changes"
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "end",
            "name": "end",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Event to emit after max time is consumed."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "tick",
            "name": "tick",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Event to emit After elapsed time (tickInterval)."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "getNativeInputId": {
            "complexType": {
                "signature": "() => Promise<HTMLGxChronometerElement>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLGxChronometerElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<HTMLGxChronometerElement>"
            },
            "docs": {
                "text": "Returns the id of the inner `input` element (if set).",
                "tags": []
            }
        },
        "start": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Starts the Chronometer",
                "tags": []
            }
        },
        "stop": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Stops the Chronometer",
                "tags": []
            }
        },
        "reset": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Stops and set to 0 the Chronometer.",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "element"; }
    static get watchers() { return [{
            "propName": "value",
            "methodName": "handleChange"
        }, {
            "propName": "state",
            "methodName": "stateChanged"
        }]; }
}
