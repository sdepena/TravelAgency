import { Component, Element, Event, Listen, Prop, State, h, Host, Watch } from "@stencil/core";
import { FeatureGroup, map as LFMap, tileLayer } from "leaflet/dist/leaflet-src.esm";
import { parseCoords } from "../common/coordsValidate";
import { watchPosition } from "./geolocation";
const MIN_ZOOM = 1;
const RECOMMENDED_MAX_ZOOM = 20;
export class Map {
    constructor() {
        this.isSelectionLayerSlot = false;
        this.markersList = [];
        this.linesList = [];
        this.mapTypesProviders = {
            hybrid: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}",
            satellite: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            standard: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        };
        /**
         * The coord of initial center of the map.
         *
         */
        this.center = "0, 0";
        /**
         * Enable the High Accuracy in user location.
         * _Note: This property applies when ```watchPosition = true```._
         */
        this.highAccuracyLocator = true;
        /**
         * Map type to be used.
         * _Note: If you set a map provider, the selected map type will be ignored._
         *
         */
        this.mapType = "standard";
        /**
         * The max zoom level available in the map.
         * _Note: 20 is the best value to be used, only lower values are allowed. Is highly recommended to no change this value if you are not sure about the `maxZoom` supported by the map._
         */
        this.maxZoom = RECOMMENDED_MAX_ZOOM;
        /**
         * Enables the possibility to navigate the map and select a location point using the map center.
         */
        this.selectionLayer = false;
        /**
         * Indicates if the current location of the device is displayed on the map.
         */
        this.watchPosition = false;
        /**
         * The initial zoom level in the map.
         *
         */
        this.zoom = 1;
    }
    userLocationHandler() {
        this.userLocationChange.emit(this.userLocationCoords);
    }
    selectionLayerHandler() {
        this.registerSelectionLayerEvents();
    }
    onMapMarkerDidLoad(event) {
        const markerElement = event.target;
        const markerV = event.detail;
        if (this.map) {
            markerV.addTo(this.map);
        }
        else {
            this.element.addEventListener("gxMapDidLoad", () => {
                markerV.addTo(this.map);
            });
        }
        if (this.selectionLayer) {
            const slot = this.getSelectionMarkerSlot();
            if (slot.exist) {
                this.selectionMarker = slot.elem;
            }
            else {
                this.selectionMarker = this.element.querySelector("[marker-class='gx-default-selection-layer-icon']");
            }
            if (markerElement !== this.selectionMarker) {
                this.markersList.push(markerV);
            }
        }
        else {
            this.markersList.push(markerV);
        }
        markerElement.addEventListener("gxMapMarkerDeleted", () => {
            this.onMapMarkerDeleted(markerV);
        });
    }
    onMapLineDidLoad(event) {
        const lineElement = event.target;
        const lineV = event.detail;
        if (this.map) {
            lineV.addTo(this.map);
        }
        else {
            this.element.addEventListener("gxMapDidLoad", () => {
                lineV.addTo(this.map);
            });
        }
        lineElement.addEventListener("gxMapLineDeleted", () => {
            this.onMapLineDeleted(lineV);
        });
    }
    addMapListener(eventToListen, callbackFunction) {
        this.map.on(eventToListen, callbackFunction);
    }
    removeMapListener(eventToListen, callbackFunction) {
        this.map.off(eventToListen, callbackFunction);
    }
    checkForMaxZoom() {
        return this.maxZoom < 20 ? this.maxZoom : RECOMMENDED_MAX_ZOOM;
    }
    fitBounds() {
        if (this.markersList.length > 1) {
            const markersGroup = new FeatureGroup(this.markersList);
            this.map.fitBounds(markersGroup.getBounds());
        }
        else if (this.markersList.length === 1) {
            const [marker] = this.markersList;
            const markerCoords = [marker._latlng.lat, marker._latlng.lng];
            this.map.setView(markerCoords, this.zoom);
        }
    }
    getZoom() {
        return this.zoom > 0
            ? this.zoom < RECOMMENDED_MAX_ZOOM
                ? this.zoom
                : RECOMMENDED_MAX_ZOOM - 1
            : MIN_ZOOM;
    }
    getSelectionMarkerSlot() {
        const slot = this.element.querySelector("[slot='selection-layer-marker']");
        return { exist: slot !== null, elem: slot };
    }
    onMapMarkerDeleted(marker) {
        let i = 0;
        marker.remove();
        while (i < this.markersList.length &&
            this.markersList[i]._leaflet_id !== marker._leaflet_id) {
            i++;
        }
        if (i <= this.markersList.length) {
            this.markersList.splice(i, 1);
        }
        else {
            console.warn("There was an error in the markers list!");
        }
    }
    onMapLineDeleted(line) {
        let i = 0;
        line.remove();
        while (i <= this.linesList.length &&
            this.linesList[i]._leaflet_id !== line._leaflet_id) {
            i++;
        }
        if (i <= this.linesList.length) {
            this.linesList.splice(i, 1);
        }
        else {
            console.warn("There was an error in the line list!");
        }
    }
    updateSelectionMarkerPosition() {
        const centerCoords = this.map.getCenter();
        this.centerCoords = `${centerCoords.lat},${centerCoords.lng}`;
        this.selectionMarker.setAttribute("coords", this.centerCoords);
    }
    registerSelectionLayerEvents() {
        if (this.selectionLayer) {
            const moveBehaivor = {
                eventTrigger: "move",
                callbackFunction: () => {
                    this.updateSelectionMarkerPosition();
                    this.selectionInput.emit(this.centerCoords);
                }
            };
            const moveEndBehaivor = {
                eventTrigger: "moveend",
                callbackFunction: () => {
                    this.updateSelectionMarkerPosition();
                    this.selectionChange.emit(this.centerCoords);
                }
            };
            if (this.selectionLayer) {
                this.addMapListener(moveBehaivor.eventTrigger, moveBehaivor.callbackFunction);
                this.addMapListener(moveEndBehaivor.eventTrigger, moveEndBehaivor.callbackFunction);
            }
            else {
                this.removeMapListener(moveBehaivor.eventTrigger, moveBehaivor.callbackFunction);
                this.removeMapListener(moveEndBehaivor.eventTrigger, moveEndBehaivor.callbackFunction);
            }
        }
    }
    selectingTypes(mapType) {
        const tileLayerToApply = tileLayer(mapType, {
            maxZoom: this.maxZoom
        });
        tileLayerToApply.addTo(this.map);
        this.mapProviderApplied = tileLayerToApply;
    }
    setMapProvider() {
        if (this.mapProviderApplied && this.tileLayerApplied) {
            this.tileLayerApplied.removeFrom(this.map);
        }
        if (this.mapProvider) {
            const tileLayerToApply = tileLayer(this.mapProvider, {
                maxZoom: this.maxZoom
            });
            tileLayerToApply.addTo(this.map);
            this.mapProviderApplied = this.mapProvider;
            this.tileLayerApplied = tileLayerToApply;
        }
        else {
            if (!this.mapType || this.mapType === "standard") {
                this.selectingTypes(this.mapTypesProviders.standard);
            }
            else {
                if (this.mapType === "hybrid") {
                    this.selectingTypes(this.mapTypesProviders.hybrid);
                }
                else if (this.mapType === "satellite") {
                    this.selectingTypes(this.mapTypesProviders.satellite);
                }
            }
        }
    }
    setUserLocation({ coords }) {
        this.userLocationCoords = `${coords.latitude}, ${coords.longitude}`;
    }
    componentWillLoad() {
        if (this.watchPosition) {
            this.watchPositionId = watchPosition(this.setUserLocation.bind(this), err => console.error(err), {
                enableHighAccuracy: this.highAccuracyLocator
            });
        }
        if (this.selectionLayer && this.getSelectionMarkerSlot().exist) {
            this.isSelectionLayerSlot = true;
        }
    }
    componentDidLoad() {
        const elementVar = this.element.querySelector(".gxMap");
        const coords = parseCoords(this.center);
        this.maxZoom = this.checkForMaxZoom();
        this.zoom = this.getZoom();
        if (coords !== null) {
            this.map = LFMap(elementVar).setView(coords, this.zoom, this.maxZoom);
        }
        else {
            console.warn("GX warning: Can not read 'center' attribute, default center set (gx-map)", this.element);
            this.map = LFMap(elementVar).setView([0, 0], this.getZoom());
        }
        this.setMapProvider();
        this.map.setMaxZoom(this.maxZoom);
        this.fitBounds();
        this.gxMapDidLoad.emit(this);
        if (this.selectionLayer) {
            this.updateSelectionMarkerPosition();
            this.registerSelectionLayerEvents();
        }
        this.addMapListener("popupopen", function (e) {
            const px = this.project(e.target._popup._latlng);
            px.y -= e.target._popup._container.clientHeight / 2;
            this.panTo(this.unproject(px), { animate: true });
        });
        this.addMapListener("click", ev => {
            this.mapClick.emit(ev.latlng);
        });
    }
    componentDidUpdate() {
        const maxZoom = this.checkForMaxZoom();
        this.setMapProvider();
        if (this.selectionLayer) {
            this.fitBounds();
        }
        this.map.setMaxZoom(maxZoom);
        this.userLocationChange.emit(this.userLocationCoords);
    }
    componentDidUnload() {
        navigator.geolocation.clearWatch(this.watchPositionId);
    }
    render() {
        return (h(Host, null,
            this.watchPosition && (h("gx-map-marker", { "marker-class": "gx-default-user-location-icon", "icon-width": "15", "icon-height": "15", coords: this.userLocationCoords })),
            this.selectionLayer &&
                (this.isSelectionLayerSlot ? (h("slot", { name: "selection-layer-marker" })) : (h("gx-map-marker", { "marker-class": "gx-default-selection-layer-icon", "icon-width": "30", "icon-height": "30", coords: this.centerCoords }))),
            h("div", { class: "gxMapContainer" },
                h("div", { class: "gxMap" }))));
    }
    static get is() { return "gx-map"; }
    static get originalStyleUrls() { return {
        "$": ["map.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["map.css"]
    }; }
    static get properties() { return {
        "center": {
            "type": "string",
            "mutable": true,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The coord of initial center of the map."
            },
            "attribute": "center",
            "reflect": false,
            "defaultValue": "\"0, 0\""
        },
        "highAccuracyLocator": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Enable the High Accuracy in user location.\n_Note: This property applies when ```watchPosition = true```._"
            },
            "attribute": "high-accuracy-locator",
            "reflect": false,
            "defaultValue": "true"
        },
        "mapProvider": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The map provider.\n_Note: Currently, this property is for setting a custom map provider using an URL._"
            },
            "attribute": "map-provider",
            "reflect": false
        },
        "mapType": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"standard\" | \"satellite\" | \"hybrid\"",
                "resolved": "\"hybrid\" | \"satellite\" | \"standard\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Map type to be used.\n_Note: If you set a map provider, the selected map type will be ignored._"
            },
            "attribute": "map-type",
            "reflect": false,
            "defaultValue": "\"standard\""
        },
        "maxZoom": {
            "type": "number",
            "mutable": true,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The max zoom level available in the map.\n_Note: 20 is the best value to be used, only lower values are allowed. Is highly recommended to no change this value if you are not sure about the `maxZoom` supported by the map._"
            },
            "attribute": "max-zoom",
            "reflect": false,
            "defaultValue": "RECOMMENDED_MAX_ZOOM"
        },
        "selectionLayer": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Enables the possibility to navigate the map and select a location point using the map center."
            },
            "attribute": "selection-layer",
            "reflect": false,
            "defaultValue": "false"
        },
        "watchPosition": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Indicates if the current location of the device is displayed on the map."
            },
            "attribute": "watch-position",
            "reflect": false,
            "defaultValue": "false"
        },
        "zoom": {
            "type": "number",
            "mutable": true,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The initial zoom level in the map."
            },
            "attribute": "zoom",
            "reflect": false,
            "defaultValue": "1"
        }
    }; }
    static get states() { return {
        "userLocationCoords": {}
    }; }
    static get events() { return [{
            "method": "gxMapDidLoad",
            "name": "gxMapDidLoad",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emmited when the map is loaded."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "mapClick",
            "name": "mapClick",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emmited when the map is clicked and return click coords."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "selectionInput",
            "name": "selectionInput",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emmited when the map is being moved, if selection layer is active."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "selectionChange",
            "name": "selectionChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emmited when the map stops from being moved, if selection layer is active."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }, {
            "method": "userLocationChange",
            "name": "userLocationChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emmited when the user location coords change."
            },
            "complexType": {
                "original": "any",
                "resolved": "any",
                "references": {}
            }
        }]; }
    static get elementRef() { return "element"; }
    static get watchers() { return [{
            "propName": "userLocationCoords",
            "methodName": "userLocationHandler"
        }, {
            "propName": "selectionLayer",
            "methodName": "selectionLayerHandler"
        }]; }
    static get listeners() { return [{
            "name": "gxMapMarkerDidLoad",
            "method": "onMapMarkerDidLoad",
            "target": undefined,
            "capture": false,
            "passive": false
        }, {
            "name": "gxMapLineDidLoad",
            "method": "onMapLineDidLoad",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
