import { Component, Element, Event, Host, Method, Prop, h } from "@stencil/core";
import { GridBaseHelper } from "../grid-base/grid-base";
export class GridSmartCss {
    constructor() {
        this.CSS_NAME_MOUSE_DRAG_ACTIVE = "gx-smart-cell-drag-active";
        /**
         * This attribute defines if the control size will grow automatically,
         * to adjust to its content size.
         * If set to `false`, it won't grow automatically and it will show scrollbars
         * if the content overflows.
         */
        this.autoGrow = false;
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * The threshold distance from the bottom
         * of the content to call the `infinite` output event when scrolled.
         * The threshold value can be either a percent, or
         * in pixels. For example, use the value of `10%` for the `infinite`
         * output event to get called when the user has scrolled 10%
         * from the bottom of the page. Use the value `100px` when the
         * scroll is within 100 pixels from the bottom of the page.
         */
        this.threshold = "150px";
        /**
          Specifies the direction of the flexible items.
         */
        this.direction = "vertical";
        /**
          Grid Item Layout Mode: Single, Multiple by quantity, multiple by size.
         */
        this.itemLayoutMode = "single";
        /**
          Scroll snapping allows to lock the viewport to certain elements or locations after a user has finished scrolling
         */
        this.snapToGrid = false;
        this.handleGxInfinite = this.handleGxInfinite.bind(this);
    }
    /*
     * This method must be called after new grid data was fetched by the infinite scroller.
     */
    async complete() {
        this.element
            .querySelector(':scope > [slot="grid-content"] gx-grid-infinite-scroll"')["complete"]();
    }
    isHorizontal() {
        return this.direction === "horizontal";
    }
    ensureViewPort() {
        const directionSize = this.isHorizontal()
            ? this.element.parentElement.offsetWidth
            : this.element.parentElement.offsetHeight;
        if (directionSize > 0) {
            const elementStyle = this.element.style;
            elementStyle.setProperty("--gx-grid-css-viewport-size", directionSize + "px");
        }
    }
    componentDidRender() {
        this.attachMouseScrollHandler();
    }
    render() {
        this.ensureViewPort();
        return (h(Host, Object.assign({}, GridBaseHelper.hostData(this)), [
            h("slot", { name: "grid-content" }),
            h("slot", { name: "grid-empty-loading-placeholder" }),
            h("div", { class: "grid-empty-placeholder" },
                h("slot", { name: "grid-content-empty" }))
        ]));
    }
    handleGxInfinite() {
        if (this.loadingState !== "loading") {
            this.gxInfiniteThresholdReached.emit();
        }
    }
    getScrollableContainer() {
        return this.element.querySelector('[slot="grid-content"]');
    }
    attachMouseScrollHandler() {
        if (!this.isHorizontal() ||
            window.matchMedia("(pointer: coarse)").matches) {
            return;
        }
        const slider = this.getScrollableContainer();
        let isDown = false;
        let startX;
        let scrollLeft;
        slider.addEventListener("mousedown", e => {
            isDown = true;
            slider.classList.add(this.CSS_NAME_MOUSE_DRAG_ACTIVE);
            startX = e.pageX - slider.offsetLeft;
            scrollLeft = slider.scrollLeft;
        });
        slider.addEventListener("mouseleave", () => {
            isDown = false;
            slider.classList.remove("active");
        });
        slider.addEventListener("mouseup", () => {
            isDown = false;
            slider.classList.remove(this.CSS_NAME_MOUSE_DRAG_ACTIVE);
        });
        slider.addEventListener("mousemove", e => {
            if (!isDown) {
                return;
            }
            e.preventDefault();
            const x = e.pageX - slider.offsetLeft;
            const SCROLL_SPEED = 1;
            const walk = (x - startX) * SCROLL_SPEED;
            slider.scrollLeft = scrollLeft - walk;
        });
    }
    static get is() { return "gx-grid-smart-css"; }
    static get originalStyleUrls() { return {
        "$": ["grid-smart-css.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["grid-smart-css.css"]
    }; }
    static get properties() { return {
        "autoGrow": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "false",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute defines if the control size will grow automatically,\nto adjust to its content size.\nIf set to `false`, it won't grow automatically and it will show scrollbars\nif the content overflows."
            },
            "attribute": "auto-grow",
            "reflect": false,
            "defaultValue": "false"
        },
        "invisibleMode": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"collapse\" | \"keep-space\"",
                "resolved": "\"collapse\" | \"keep-space\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This attribute lets you specify how this element will behave when hidden.\n\n| Value        | Details                                                                     |\n| ------------ | --------------------------------------------------------------------------- |\n| `keep-space` | The element remains in the document flow, and it does occupy space.         |\n| `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |"
            },
            "attribute": "invisible-mode",
            "reflect": false,
            "defaultValue": "\"collapse\""
        },
        "loadingState": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"loading\" | \"loaded\"",
                "resolved": "\"loaded\" | \"loading\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Grid loading State. It's purpose is to know rather the Grid Loading animation or the Grid Empty placeholder should be shown.\n\n| Value        | Details                                                                                        |\n| ------------ | ---------------------------------------------------------------------------------------------- |\n| `loading` | The grid is waiting the server for the grid data. Grid loading mask will be shown.                |\n| `loaded`   | The grid data has been loaded. If the grid has no records, the empty place holder will be shown. |"
            },
            "attribute": "loading-state",
            "reflect": false
        },
        "recordCount": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Grid current row count. This property is used in order to be able to re-render the Grid every time the Grid data changes.\nIf not specified, then grid empty and loading placeholders may not work correctly."
            },
            "attribute": "record-count",
            "reflect": false
        },
        "threshold": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The threshold distance from the bottom\nof the content to call the `infinite` output event when scrolled.\nThe threshold value can be either a percent, or\nin pixels. For example, use the value of `10%` for the `infinite`\noutput event to get called when the user has scrolled 10%\nfrom the bottom of the page. Use the value `100px` when the\nscroll is within 100 pixels from the bottom of the page."
            },
            "attribute": "threshold",
            "reflect": false,
            "defaultValue": "\"150px\""
        },
        "direction": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"vertical\" | \"horizontal\"",
                "resolved": "\"horizontal\" | \"vertical\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Specifies the direction of the flexible items."
            },
            "attribute": "direction",
            "reflect": true,
            "defaultValue": "\"vertical\""
        },
        "itemLayoutMode": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"single\" | \"mbyq\" | \"mbys\"",
                "resolved": "\"mbyq\" | \"mbys\" | \"single\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Grid Item Layout Mode: Single, Multiple by quantity, multiple by size."
            },
            "attribute": "item-layout-mode",
            "reflect": true,
            "defaultValue": "\"single\""
        },
        "snapToGrid": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "false",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Scroll snapping allows to lock the viewport to certain elements or locations after a user has finished scrolling"
            },
            "attribute": "snap-to-grid",
            "reflect": true,
            "defaultValue": "false"
        }
    }; }
    static get events() { return [{
            "method": "gxInfiniteThresholdReached",
            "name": "gxInfiniteThresholdReached",
            "bubbles": false,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "This Handler will be called every time grid threshold is reached. Needed for infinite scrolling grids."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "complete": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "element"; }
}
