import { Component, Element, Event, Method, Prop, State, Watch, Host, h } from "@stencil/core";
export class GridInfiniteScroll {
    constructor() {
        this.thrPx = 0;
        this.thrPc = 0;
        this.scrollEl = null;
        this.didFire = false;
        this.isBusy = false;
        this.attachedToWindow = false;
        this.attached = false;
        this.supported = true;
        this.isLoading = false;
        /**
         * This property must be bounded to grid item count property.
         * It's unique purpose is to trigger gxInfinite as many times as needed to fullfill the Container space when the intial batch does not overflow the main container
         */
        this.itemCount = 0;
        /**
         * The threshold distance from the bottom
         * of the content to call the `infinite` output event when scrolled.
         * The threshold value can be either a percent, or
         * in pixels. For example, use the value of `10%` for the `infinite`
         * output event to get called when the user has scrolled 10%
         * from the bottom of the page. Use the value `100px` when the
         * scroll is within 100 pixels from the bottom of the page.
         */
        this.threshold = "15%";
        /**
         * If `true`, the infinite scroll will be hidden and scroll event listeners
         * will be removed.
         *
         * Set this to true to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         */
        this.disabled = false;
        /**
         * The position of the infinite scroll element.
         * The value can be either `top` or `bottom`.
         */
        this.position = "bottom";
        this.onScroll = this.onScroll.bind(this);
    }
    componentWillLoad() {
        this.itemCountChanged();
    }
    itemCountChanged() {
        if (this.disabled || this.itemCount === 0) {
            return;
        }
        setTimeout(() => {
            let emitInfinite = false;
            if (this.ensure()) {
                emitInfinite = this.isVisibleInViewport(this.el);
                if (emitInfinite) {
                    this.gxInfinite.emit();
                }
            }
        }, 100);
    }
    disabledChanged(val) {
        if (this.disabled) {
            this.isLoading = false;
            this.isBusy = false;
        }
        this.enableScrollEvents(!val);
    }
    thresholdChanged(val) {
        if (val.lastIndexOf("%") > -1) {
            this.thrPx = 0;
            this.thrPc = parseFloat(val) / 100;
        }
        else {
            this.thrPx = parseFloat(val);
            this.thrPc = 0;
        }
    }
    isVisibleInViewport(el) {
        const rect = el.getBoundingClientRect();
        const elemTop = rect.top;
        const element = this.getScrollListener();
        return (el.style.display !== "none" &&
            elemTop >= 0 &&
            elemTop <= (element["clientHeight"] || element["innerHeight"]));
    }
    getScrollParent(node) {
        if (node === null) {
            return null;
        }
        if (node === window.document.documentElement) {
            return node;
        }
        if (this.viewportSelector) {
            const scrollParent = node.closest(this.viewportSelector);
            if (scrollParent != null) {
                //When parent scroller is known before hand.
                return scrollParent;
            }
        }
        //We try to search for first scrollable parent element.
        const overflow = window.getComputedStyle(node).overflowY;
        if (node.scrollHeight > node.clientHeight || overflow === "scroll") {
            return node;
        }
        return this.getScrollParent(node.parentNode);
    }
    ensure() {
        if (this.disabled || this.attached || this.itemCount === 0) {
            return this.supported;
        }
        //Horizontal Orientation not supported
        const gridComponent = this.el.closest(".gx-grid-base");
        if (gridComponent &&
            gridComponent.getAttribute("direction") === "horizontal") {
            this.supported = false;
            return this.supported;
        }
        let contentEl = this.getScrollParent(this.el);
        if (contentEl !== null) {
            if (contentEl === window.document.documentElement) {
                this.scrollListenerEl = null;
                contentEl = window.document.body;
                this.attachedToWindow = true;
            }
            else {
                this.scrollListenerEl = contentEl;
            }
            this.scrollEl = contentEl;
            this.thresholdChanged(this.threshold);
            this.enableScrollEvents(!this.disabled);
            this.attached = !this.disabled;
            if (this.position === "top") {
                this.queue.write(() => {
                    if (this.scrollEl !== null) {
                        this.scrollEl.scrollTop =
                            this.scrollEl.scrollHeight - this.scrollEl.clientHeight;
                    }
                });
            }
        }
        return this.supported;
    }
    async componentDidLoad() {
        this.ensure();
    }
    componentDidUnload() {
        this.scrollEl = null;
        this.attachedToWindow = false;
        this.attached = false;
        this.scrollListenerEl = null;
    }
    onScroll() {
        const scrollEl = this.scrollEl;
        if (scrollEl === null || !this.canStart()) {
            return 1;
        }
        const infiniteHeight = this.el.offsetHeight;
        const scrollTop = !this.attachedToWindow
            ? scrollEl.scrollTop
            : window.scrollY;
        const scrollHeight = scrollEl.scrollHeight;
        const height = !this.attachedToWindow
            ? scrollEl.offsetHeight
            : window.innerHeight;
        const threshold = this.thrPc !== 0 ? height * this.thrPc : this.thrPx;
        const distanceFromInfinite = this.position === "bottom"
            ? scrollHeight - infiniteHeight - scrollTop - threshold - height
            : scrollTop - infiniteHeight - threshold;
        if (distanceFromInfinite < 0) {
            if (!this.didFire) {
                this.isLoading = true;
                this.didFire = true;
                this.gxInfinite.emit();
                return 3;
            }
        }
        else {
            this.didFire = false;
        }
        return 4;
    }
    /**
     * Call `complete()` within the `gxInfinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     */
    async complete() {
        const scrollEl = this.scrollEl;
        if (!this.isLoading || scrollEl === null) {
            return;
        }
        this.isLoading = false;
        if (this.position === "top") {
            /**
             * New content is being added at the top, but the scrollTop position stays the same,
             * which causes a scroll jump visually. This algorithm makes sure to prevent this.
             * (Frame 1)
             *    - complete() is called, but the UI hasn't had time to update yet.
             *    - Save the current content dimensions.
             *    - Wait for the next frame using _dom.read, so the UI will be updated.
             * (Frame 2)
             *    - Read the new content dimensions.
             *    - Calculate the height difference and the new scroll position.
             *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.
             * (Still frame 2, if I'm correct)
             *    - Change the scroll position (= visually maintain the scroll position).
             *    - Change the state to re-enable the InfiniteScroll.
             *    - This should be after changing the scroll position, or it could
             *    cause the InfiniteScroll to be triggered again immediately.
             * (Frame 3)
             *    Done.
             */
            this.isBusy = true;
            // ******** DOM READ ****************
            // Save the current content dimensions before the UI updates
            const prev = scrollEl.scrollHeight - scrollEl.scrollTop;
            // ******** DOM READ ****************
            requestAnimationFrame(() => {
                this.queue.read(() => {
                    // UI has updated, save the new content dimensions
                    const scrollHeight = scrollEl.scrollHeight;
                    // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around
                    const newScrollTop = scrollHeight - prev;
                    // ******** DOM WRITE ****************
                    requestAnimationFrame(() => {
                        this.queue.write(() => {
                            scrollEl.scrollTop = newScrollTop;
                            this.isBusy = false;
                        });
                    });
                });
            });
        }
    }
    canStart() {
        return (!this.disabled &&
            !this.isBusy &&
            this.scrollEl !== null &&
            !this.isLoading &&
            this.supported);
    }
    getScrollListener() {
        if (this.attachedToWindow) {
            return window;
        }
        else {
            return this.scrollListenerEl;
        }
    }
    enableScrollEvents(shouldListen) {
        const scrollListener = this.getScrollListener();
        if (scrollListener !== null) {
            if (shouldListen) {
                scrollListener.addEventListener("scroll", this.onScroll);
            }
            else {
                scrollListener.removeEventListener("scroll", this.onScroll);
            }
        }
    }
    render() {
        return (h(Host, { class: {
                "infinite-scroll-enabled": !this.disabled,
                "infinite-scroll-loading": this.isLoading
            } }));
    }
    static get is() { return "gx-grid-infinite-scroll"; }
    static get originalStyleUrls() { return {
        "$": ["grid-infinite-scroll.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["grid-infinite-scroll.css"]
    }; }
    static get properties() { return {
        "itemCount": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "This property must be bounded to grid item count property.\nIt's unique purpose is to trigger gxInfinite as many times as needed to fullfill the Container space when the intial batch does not overflow the main container"
            },
            "attribute": "item-count",
            "reflect": false,
            "defaultValue": "0"
        },
        "threshold": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The threshold distance from the bottom\nof the content to call the `infinite` output event when scrolled.\nThe threshold value can be either a percent, or\nin pixels. For example, use the value of `10%` for the `infinite`\noutput event to get called when the user has scrolled 10%\nfrom the bottom of the page. Use the value `100px` when the\nscroll is within 100 pixels from the bottom of the page."
            },
            "attribute": "threshold",
            "reflect": false,
            "defaultValue": "\"15%\""
        },
        "disabled": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "If `true`, the infinite scroll will be hidden and scroll event listeners\nwill be removed.\n\nSet this to true to disable the infinite scroll from actively\ntrying to receive new data while scrolling. This is useful\nwhen it is known that there is no more data that can be added, and\nthe infinite scroll is no longer needed."
            },
            "attribute": "disabled",
            "reflect": false,
            "defaultValue": "false"
        },
        "position": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"top\" | \"bottom\"",
                "resolved": "\"bottom\" | \"top\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The position of the infinite scroll element.\nThe value can be either `top` or `bottom`."
            },
            "attribute": "position",
            "reflect": false,
            "defaultValue": "\"bottom\""
        },
        "viewportSelector": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "The View Port parent element selector where the infinite component would be attached to\nand listening to Scroll Events."
            },
            "attribute": "viewport-selector",
            "reflect": false
        }
    }; }
    static get contextProps() { return [{
            "name": "queue",
            "context": "queue"
        }]; }
    static get states() { return {
        "isLoading": {}
    }; }
    static get events() { return [{
            "method": "gxInfinite",
            "name": "gxInfinite",
            "bubbles": false,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Emitted when the scroll reaches\nthe threshold distance. From within your infinite handler,\nyou must call the infinite scroll's `complete()` method when\nyour async operation has completed."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "complete": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Call `complete()` within the `gxInfinite` output event handler when\nyour async operation has completed. For example, the `loading`\nstate is while the app is performing an asynchronous operation,\nsuch as receiving more data from an AJAX request to add more items\nto a data list. Once the data has been received and UI updated, you\nthen call this method to signify that the loading has completed.\nThis method will change the infinite scroll's state from `loading`\nto `enabled`.",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "el"; }
    static get watchers() { return [{
            "propName": "itemCount",
            "methodName": "itemCountChanged"
        }, {
            "propName": "disabled",
            "methodName": "disabledChanged"
        }, {
            "propName": "threshold",
            "methodName": "thresholdChanged"
        }]; }
}
