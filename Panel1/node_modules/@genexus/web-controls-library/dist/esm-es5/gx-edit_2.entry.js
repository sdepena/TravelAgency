var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { h, r as registerInstance, c as createEvent, H as Host, g as getElement } from './index-10623738.js';
import { m as makeHighlightable } from './highlightable-49b186e7.js';
import { c as cssVariablesWatcher, m as makeLinesClampable } from './line-clamp-165ccce6.js';
var autoEditId = 0;
var fontCategoryTagMap = {
    body: "p",
    caption1: "span",
    caption2: "span",
    footnote: "footer",
    headline: "h1",
    subheadline: "h2"
};
var EditRender = /** @class */ (function () {
    function EditRender(component, handlers) {
        this.component = component;
        this.handleChange = handlers.handleChange;
        this.handleTriggerClick = handlers.handleTriggerClick;
        this.handleValueChanging = handlers.handleValueChanging;
    }
    EditRender.prototype.getNativeInputId = function () {
        return this.getNativeInput().id;
    };
    EditRender.prototype.getNativeInput = function () {
        return this.component.element.querySelector("[data-native-element]");
    };
    EditRender.prototype.getCssClasses = function () {
        var edit = this.component;
        var classList = [];
        if (edit.type === "file") {
            classList.push("form-control-file");
        }
        else {
            classList.push("form-control");
        }
        return classList.join(" ");
    };
    EditRender.prototype.getTriggerCssClasses = function () {
        var classList = [];
        classList.push("btn");
        classList.push("btn-outline-secondary");
        return classList.join(" ");
    };
    EditRender.prototype.getValueFromEvent = function (event) {
        return event.target && event.target.value;
    };
    EditRender.prototype.stopPropagation = function (event) {
        event.stopPropagation();
    };
    EditRender.prototype.getReadonlyContent = function (component, initialContent) {
        var content = initialContent;
        if (content &&
            (component.type === "datetime-local" || component.type === "date")) {
            var dateTime = new Date(component.value);
            if (component.type === "date") {
                dateTime.setDate(dateTime.getDate() + 1);
            }
            var dayMonthYear = new Intl.DateTimeFormat("default", {
                year: "numeric",
                month: "numeric",
                day: "numeric"
            }).format(dateTime);
            if (component.type === "date") {
                content = "" + dayMonthYear;
            }
            else {
                var hourMins = new Intl.DateTimeFormat("default", {
                    hour: "numeric",
                    minute: "numeric"
                }).format(dateTime);
                content = dayMonthYear + " " + hourMins;
            }
        }
        return content;
    };
    /**
     * Update the native input element when the value changes
     */
    EditRender.prototype.valueChanged = function () {
        var inputEl = this.getNativeInput();
        if (inputEl && inputEl.value !== this.component.value) {
            inputEl.value = this.component.value;
        }
    };
    EditRender.prototype.render = function (slots) {
        var edit = this.component;
        var valueChangingHandler = this.handleValueChanging;
        if (!this.inputId) {
            this.inputId = edit.element.id
                ? edit.element.id + "__edit"
                : "gx-edit-auto-id-" + autoEditId++;
        }
        var attris = {
            "aria-disabled": edit.disabled ? "true" : undefined,
            autocapitalize: edit.autocapitalize,
            autocomplete: edit.autocomplete,
            autocorrect: edit.autocorrect,
            class: this.getCssClasses(),
            "data-native-element": "",
            disabled: edit.disabled,
            hidden: edit.readonly,
            id: this.inputId,
            onChange: this.handleChange,
            onInput: valueChangingHandler,
            onClick: edit.disabled ? null : this.stopPropagation,
            placeholder: edit.placeholder
        };
        var editableElement;
        if (edit.multiline) {
            editableElement = h("textarea", Object.assign({}, attris), edit.value);
        }
        else {
            var input = h("input", Object.assign({}, attris, { type: edit.type, value: edit.value }));
            if (edit.showTrigger) {
                var existSlotContent = edit.element.querySelector("[slot='trigger-content']");
                editableElement = (h("div", { class: "input-group", hidden: edit.readonly }, input, h("div", { class: "input-group-append" }, h("button", { class: this.getTriggerCssClasses(), onClick: this.handleTriggerClick, type: "button", disabled: edit.disabled, "aria-label": edit.triggerText }, existSlotContent !== null
                    ? slots.triggerContent
                    : edit.triggerText))));
            }
            else {
                editableElement = input;
            }
        }
        var ReadonlyTag = this.getReadonlyTagByFontCategory();
        return [
            h("gx-bootstrap", null),
            h(ReadonlyTag, { key: "readonly", hidden: !edit.readonly, "data-readonly": "", class: {
                    "gx-line-clamp": this.shouldClampLines()
                }, style: this.shouldClampLines() && {
                    "--max-lines": edit.maxLines.toString(),
                    "--max-height": edit.maxHeight + "px"
                } }, edit.lineClamp && (h("div", { class: "line-measuring", "aria-hidden": true }, "A")), this.getReadonlyContent(edit, edit.value)),
            editableElement
        ];
    };
    EditRender.prototype.getReadonlyTagByFontCategory = function () {
        var tag = fontCategoryTagMap[this.component.fontCategory];
        if (!tag) {
            return "span";
        }
        return tag;
    };
    EditRender.prototype.shouldClampLines = function () {
        return this.component.lineClamp && this.component.maxLines > 0;
    };
    return EditRender;
}());
var editCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-edit [data-native-element]{margin-top:var(--margin-top, 0);margin-bottom:var(--margin-bottom, 0);height:unset}gx-edit [data-native-element]:focus{-webkit-box-shadow:none;box-shadow:none}gx-edit:not([show-trigger]) [slot=trigger-content],gx-edit[show-trigger=false] [slot=trigger-content]{display:none}gx-edit:not([show-trigger]) [data-native-element],gx-edit[show-trigger=false] [data-native-element]{margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0)}gx-edit[show-trigger] .input-group,gx-edit[show-trigger=true] .input-group{margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0)}gx-edit [data-readonly]{margin:0;margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0);margin-top:var(--margin-top, 0);margin-bottom:var(--margin-bottom, 0);padding:0;line-height:1.2;white-space:break-spaces;-ms-flex:1;flex:1}gx-edit h1,gx-edit h2,gx-edit footer{font-size:inherit;font-weight:inherit}gx-table-cell[align=center]>gx-edit,gx-table-cell[align=right]>gx-edit{-ms-flex-preferred-size:auto;flex-basis:auto;-ms-flex-positive:0;flex-grow:0}gx-edit{display:-ms-flexbox;display:flex;-ms-flex-align:stretch;align-items:stretch;-ms-flex:1;flex:1}gx-edit[hidden]{display:none !important}gx-edit[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}gx-edit.gx-edit--single-line [data-readonly]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}";
var Edit = /** @class */ (function () {
    function class_1(hostRef) {
        registerInstance(this, hostRef);
        this.change = createEvent(this, "change", 7);
        this.input = createEvent(this, "input", 7);
        this.gxTriggerClick = createEvent(this, "gxTriggerClick", 7);
        /**
         * Used to define the semantic of the element when readonly=true.
         *
         * Font categories are mapped to semantic HTML elements when rendered:
         *
         * * `"headline"`: `h1`
         * * `"subheadline"`: `h2`
         * * `"body"`: `p`
         * * `"footnote"`: `footer`
         * * `"caption1"`: `span`
         * * `"caption2"`: `span`
         */
        this.fontCategory = "body";
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * This attribute lets you specify if the element is disabled.
         * If disabled, it will not fire any user interaction related event
         * (for example, click event).
         */
        this.disabled = false;
        /**
         * True to cut text when it overflows, showing an ellipsis (only applies when readonly)
         */
        this.lineClamp = false;
        /**
         * The type of control to render. A subset of the types supported by the `input` element is supported:
         *
         * * `"date"`
         * * `"datetime-local"`
         * * `"email"`
         * * `"file"`
         * * `"number"`
         * * `"password"`
         * * `"search"`
         * * `"tel"`
         * * `"text"`
         * * `"url"`
         */
        this.type = "text";
        /**
         * True to highlight control when an action is fired.
         */
        this.highlightable = false;
        this.maxLines = 0;
        this.maxHeight = 0;
        this.renderer = new EditRender(this, {
            handleChange: this.handleChange.bind(this),
            handleTriggerClick: this.handleTriggerClick.bind(this),
            handleValueChanging: this.handleValueChanging.bind(this)
        });
        cssVariablesWatcher(this, [
            {
                cssVariableName: "--font-category",
                propertyName: "fontCategory"
            }
        ]);
        makeLinesClampable(this, "[data-readonly]", ".line-measuring");
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    class_1.prototype.getNativeInputId = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.renderer.getNativeInputId()];
            });
        });
    };
    class_1.prototype.componentDidLoad = function () {
        this.toggleValueSetClass();
        if (this.readonly) {
            makeHighlightable(this);
        }
    };
    class_1.prototype.valueChanged = function () {
        this.renderer.valueChanged();
        this.toggleValueSetClass();
    };
    class_1.prototype.toggleValueSetClass = function () {
        if (this.value === "") {
            this.element.classList.remove("value-set");
        }
        else {
            this.element.classList.add("value-set");
        }
    };
    class_1.prototype.handleChange = function (event) {
        this.value = this.renderer.getValueFromEvent(event);
        this.change.emit(event);
    };
    class_1.prototype.handleValueChanging = function (event) {
        this.value = this.renderer.getValueFromEvent(event);
        this.input.emit(event);
    };
    class_1.prototype.handleTriggerClick = function (event) {
        if (!this.disabled) {
            event.stopPropagation();
        }
        this.gxTriggerClick.emit(event);
    };
    class_1.prototype.render = function () {
        return (h(Host, { class: {
                "gx-edit--single-line": this.type === "date" || this.type === "datetime-local"
            } }, this.renderer.render({
            triggerContent: h("slot", { name: "trigger-content" })
        })));
    };
    Object.defineProperty(class_1.prototype, "element", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(class_1, "watchers", {
        get: function () {
            return {
                "value": ["valueChanged"]
            };
        },
        enumerable: false,
        configurable: true
    });
    return class_1;
}());
Edit.style = editCss;
var autoFormFieldId = 0;
var FormFieldRender = /** @class */ (function () {
    function FormFieldRender(component) {
        this.component = component;
        this.LABEL_WIDTH_BY_POSITION = {
            bottom: "label-bottom",
            float: "",
            left: "label-left",
            none: "sr-only",
            right: "label-right",
            top: "label-top"
        };
        this.INNER_CONTROL_WIDTH_BY_LABEL_POSITION = {
            bottom: "field-label-bottom",
            float: "",
            left: "field-label-left",
            none: "field-label-top",
            right: "field-label-right",
            top: "field-label-top"
        };
    }
    FormFieldRender.prototype.getLabelCssClass = function () {
        var classList = [];
        classList.push(this.LABEL_WIDTH_BY_POSITION[this.component.labelPosition]);
        if (this.component.labelPosition !== "float") {
            classList.push("col-form-label");
        }
        return classList.join(" ");
    };
    FormFieldRender.prototype.getInnerControlContainerClass = function () {
        var _a;
        var className = this.INNER_CONTROL_WIDTH_BY_LABEL_POSITION[this.component.labelPosition];
        return _a = {},
            _a[className] = true,
            _a["d-flex"] = true,
            _a;
    };
    FormFieldRender.prototype.shouldRenderLabelBefore = function () {
        var formField = this.component;
        return (!formField.labelPosition ||
            formField.labelPosition === "top" ||
            formField.labelPosition === "right" ||
            formField.labelPosition === "bottom" ||
            formField.labelPosition === "left" ||
            formField.labelPosition === "none");
    };
    FormFieldRender.prototype.componentDidLoad = function () {
        return __awaiter(this, void 0, void 0, function () {
            var formField, innerControl, nativeInputId, nativeInput, innerLabel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        formField = this.component;
                        innerControl = formField.element.querySelector("[area='field']");
                        if (!(innerControl && innerControl.getNativeInputId)) return [3 /*break*/, 2];
                        return [4 /*yield*/, innerControl.getNativeInputId()];
                    case 1:
                        nativeInputId = _a.sent();
                        if (nativeInputId) {
                            nativeInput = formField.element.querySelector("#" + nativeInputId);
                            if (nativeInput !== null) {
                                nativeInput.setAttribute("data-part", "field");
                            }
                            innerLabel = formField.element.querySelector("label");
                            if (nativeInputId && innerLabel) {
                                innerLabel.setAttribute("for", nativeInputId);
                            }
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    FormFieldRender.prototype.renderForRadio = function (renderLabel, renderLabelBefore, slot) {
        var _a;
        var labelId = this.formFieldId + "-label";
        var label = (h("div", { class: this.getLabelCssClass(), id: labelId, "data-part": "label" }, h("div", { class: "label-content" }, this.component.labelCaption)));
        var labelPositionClassName = "label-position-" + this.component.labelPosition;
        var isValidLabelPosition = this.component.labelPosition === "top" ||
            this.component.labelPosition === "right" ||
            this.component.labelPosition === "bottom" ||
            this.component.labelPosition === "left";
        return (h("div", { class: "form-group mb-0", "aria-labelledby": labelId, role: "group" }, h("div", { class: (_a = {
                    "radio-group": true,
                    "no-gutters": true
                },
                _a[labelPositionClassName] = isValidLabelPosition,
                _a) }, renderLabel && renderLabelBefore ? label : null, h("div", { class: this.getInnerControlContainerClass() }, slot), renderLabel && !renderLabelBefore ? label : null)));
    };
    FormFieldRender.prototype.render = function (slots) {
        var formField = this.component;
        var isRadioGroup = formField.element.querySelector("gx-radio-group[area='field']") !== null;
        var renderLabelBefore = this.shouldRenderLabelBefore();
        var renderLabel = formField.labelPosition !== "none";
        if (!this.formFieldId) {
            this.formFieldId =
                formField.element.id || "gx-form-field-auto-id-" + autoFormFieldId++;
        }
        if (isRadioGroup) {
            return this.renderForRadio(renderLabel, renderLabelBefore, slots.default);
        }
        else {
            var label = (h("label", { class: this.getLabelCssClass(), "data-part": "label" }, h("div", { class: "label-content" }, formField.labelCaption)));
            var result = formField.labelPosition === "float" ? (h("div", null, slots.default, label)) : (h("div", { class: {
                    "form-group": true,
                    "no-gutters": true,
                    "mb-0": true,
                    "flex-column": formField.labelPosition === "top",
                    "flex-column-reverse": formField.labelPosition === "bottom",
                    "flex-row-reverse": formField.labelPosition === "right",
                    "flex-row": formField.labelPosition === "left"
                } }, renderLabel && renderLabelBefore ? label : null, h("div", { class: this.getInnerControlContainerClass() }, slots.default), renderLabel && !renderLabelBefore ? label : null));
            return [h("gx-bootstrap", null), result];
        }
    };
    return FormFieldRender;
}());
var formFieldCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-form-field{--elevation:0}gx-form-field [data-part=field]{-webkit-box-shadow:0 calc(var(--elevation) * 0.125rem) calc(var(--elevation) * 0.25rem) rgba(0, 0, 0, calc(var(--elevation) * 0.075));box-shadow:0 calc(var(--elevation) * 0.125rem) calc(var(--elevation) * 0.25rem) rgba(0, 0, 0, calc(var(--elevation) * 0.075))}gx-form-field[label-position=float]>div{position:relative;margin-bottom:1em;--input-padding-y:0.4em;--input-padding-x:0.7rem}gx-form-field[label-position=float]>div input,gx-form-field[label-position=float]>div>label{padding:var(--input-padding-y) var(--input-padding-x)}gx-form-field[label-position=float]>div>label{position:absolute;top:0;left:0;display:block;width:100%;margin-bottom:0;line-height:1.5;color:#495057;border:1px solid transparent;border-radius:0.25em;-webkit-transition:all 0.1s ease-in-out;transition:all 0.1s ease-in-out}gx-form-field[label-position=float]>div input::-webkit-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input:-ms-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input::-ms-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input::-moz-placeholder{color:transparent}gx-form-field[label-position=float]>div input::placeholder{color:transparent}gx-form-field[label-position=float]>div [area=field].value-set input{padding-top:calc( var(--input-padding-y) + var(--input-padding-y) * (2 / 3) );padding-bottom:calc(var(--input-padding-y) / 3)}gx-form-field[label-position=float]>div [area=field].value-set~label{padding-top:calc(var(--input-padding-y) / 3);padding-bottom:calc(var(--input-padding-y) / 3);font-size:12px;color:#777}gx-form-field .label-position-top{-ms-flex-direction:column;flex-direction:column}gx-form-field .label-position-right{-ms-flex-direction:row-reverse;flex-direction:row-reverse}gx-form-field .label-position-bottom{-ms-flex-direction:column-reverse;flex-direction:column-reverse}gx-form-field .label-position-left{-ms-flex-direction:row;flex-direction:row}gx-form-field .label-left,gx-form-field .label-right{position:relative;width:100%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}gx-form-field .label-right{text-align:right}gx-form-field .label-top,gx-form-field .label-bottom,gx-form-field .field-label-top,gx-form-field .field-label-bottom{position:relative;width:100%;max-width:100%}gx-form-field .label-top,gx-form-field .label-bottom{-ms-flex:0;flex:0}gx-form-field .field-label-top,gx-form-field .field-label-bottom{-ms-flex:1;flex:1}gx-form-field .field-label-left,gx-form-field .field-label-right{position:relative;width:100%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}gx-form-field .label-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}gx-form-field>.form-group{max-height:100%;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-wrap:nowrap;flex-wrap:nowrap}gx-form-field>.form-group>div{-ms-flex:1;flex:1;max-height:100%}gx-form-field .radio-group{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-wrap:wrap;flex-wrap:wrap}gx-form-field gx-checkbox .custom-checkbox{padding-top:calc(1.375rem + 1px);padding-left:0.75rem}gx-form-field gx-checkbox .custom-control-label:before,gx-form-field gx-checkbox .custom-control-label:after{top:calc(0.25em - 15px)}gx-form-field gx-radio-option .custom-radio{padding-top:calc(0.375em + 1px)}gx-form-field gx-radio-option .custom-control-label:before,gx-form-field gx-radio-option .custom-control-label:after{top:calc(-0.15em + 7px)}gx-table-cell[align=center]>gx-form-field .label-left,gx-table-cell[align=center]>gx-form-field .label-right,gx-table-cell[align=center]>gx-form-field .field-label-left,gx-table-cell[align=center]>gx-form-field .field-label-right,gx-table-cell[align=right]>gx-form-field .label-left,gx-table-cell[align=right]>gx-form-field .label-right,gx-table-cell[align=right]>gx-form-field .field-label-left,gx-table-cell[align=right]>gx-form-field .field-label-right{-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}gx-form-field{display:-ms-flexbox;display:flex;justify-self:stretch;-ms-flex-item-align:stretch;align-self:stretch;-ms-flex:1;flex:1}gx-form-field[hidden]{display:none !important}gx-form-field[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}[align=center]>gx-form-field [data-part=field],[align=center]>gx-form-field [data-readonly]{text-align:center}[align=right]>gx-form-field [data-part=field],[align=right]>gx-form-field [data-readonly]{text-align:right}[valign=middle]>gx-form-field [data-readonly],[valign=middle]>gx-form-field [data-part=label]{-ms-flex-item-align:center;align-self:center}[valign=bottom]>gx-form-field [data-readonly]{-ms-flex-item-align:end;align-self:flex-end;line-height:1.25}[valign=bottom]>gx-form-field [data-part=label]{-ms-flex-item-align:end;align-self:flex-end}";
var FormField = /** @class */ (function () {
    function FormField(hostRef) {
        registerInstance(this, hostRef);
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        this.renderer = new FormFieldRender(this);
    }
    FormField.prototype.componentDidLoad = function () {
        this.renderer.componentDidLoad();
    };
    FormField.prototype.render = function () {
        return this.renderer.render({ default: h("slot", null) });
    };
    Object.defineProperty(FormField.prototype, "element", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    return FormField;
}());
FormField.style = formFieldCss;
export { Edit as gx_edit, FormField as gx_form_field };
