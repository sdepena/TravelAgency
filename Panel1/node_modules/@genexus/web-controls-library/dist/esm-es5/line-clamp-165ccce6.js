function debounce(func, wait, immediate) {
    if (immediate === void 0) { immediate = false; }
    var timeout;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var later = function () {
            timeout = null;
            if (!immediate) {
                func.apply(this, args);
            }
        }.bind(this);
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(this, args);
        }
    };
}
function overrideMethod(component, methodName, _a) {
    var before = _a.before, after = _a.after;
    var oldMethod = component[methodName];
    component[methodName] = function () {
        if (before !== undefined) {
            before();
        }
        if (oldMethod !== undefined) {
            oldMethod.call(component);
        }
        if (after !== undefined) {
            after();
        }
    };
}
function cssVariablesWatcher(component, properties) {
    var updatePropertiesFromCss = debounce(function () {
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var prop = properties_1[_i];
            var propCssValue = getComputedStyle(component.element)
                .getPropertyValue(prop.cssVariableName)
                .trim();
            if (propCssValue && component[prop.propertyName] !== propCssValue) {
                component[prop.propertyName] = propCssValue;
            }
        }
    }, 100);
    // Set up a MutationObserver to monitor changes on style and class attributes.
    // When a change occurs on this attributes, the properties listed in
    // properties are updated with their corresponding CSS variables values.
    // The properties will be kept in sync with the CSS variables values.
    // The properties must have the mutable flag set to true.
    var classObserver = new MutationObserver(function (mutationsList) {
        for (var _i = 0, mutationsList_1 = mutationsList; _i < mutationsList_1.length; _i++) {
            var mutation = mutationsList_1[_i];
            if (mutation.type === "attributes" &&
                (mutation.attributeName === "class" ||
                    mutation.attributeName === "style")) {
                updatePropertiesFromCss();
            }
        }
    });
    // componentDidLoad, componentDidUpdate and componentDidUnload are overriden
    // to start and end observing the mutations, and to update the properties values.
    overrideMethod(component, "componentDidLoad", {
        after: function () { return updatePropertiesFromCss(); },
        before: function () {
            classObserver.observe(component.element, {
                attributes: true,
                childList: false,
                subtree: false
            });
        }
    });
    overrideMethod(component, "componentDidUpdate", {
        after: function () { return updatePropertiesFromCss(); }
    });
    overrideMethod(component, "componentDidUnload", {
        before: function () { return classObserver.disconnect(); }
    });
}
var LINE_HEIGHT_CLAMP_THRESHOLD = 0.3;
function makeLinesClampable(component, contentElementSelect, lineMeasuringElementSelector) {
    var applyLineClamp = debounce(function () {
        requestAnimationFrame(function applyLineClampImpl() {
            var contentElement = component.element.querySelector(contentElementSelect);
            var lineMeasuringElement = component.element.querySelector(lineMeasuringElementSelector);
            if (contentElement === null || lineMeasuringElement === null) {
                return;
            }
            var offsetHeight = contentElement.offsetHeight, scrollHeight = contentElement.scrollHeight;
            var delta = scrollHeight - offsetHeight;
            var lineHeight = lineMeasuringElement.clientHeight;
            if (delta > lineHeight * LINE_HEIGHT_CLAMP_THRESHOLD) {
                component.maxLines = Math.trunc(offsetHeight / lineHeight);
                component.maxHeight = component.maxLines * lineHeight;
            }
        });
    }, 100);
    var resetLineClamp = function resetLineClampImpl() {
        component.maxLines = 0;
    };
    var resizeObserver = null;
    overrideMethod(component, "componentDidLoad", {
        before: function () {
            if (component.lineClamp) {
                resizeObserver = new ResizeObserver(function () {
                    // If the component resizes, we reset the clamping and wait after the next paint to calculate sizes again
                    // to check if clamping is needed
                    resetLineClamp();
                    applyLineClamp();
                });
                resizeObserver.observe(component.element);
            }
        }
    });
    overrideMethod(component, "componentDidRender", {
        before: function () {
            if (component.lineClamp) {
                applyLineClamp();
            }
        }
    });
    overrideMethod(component, "disconnectedCallback", {
        before: function () {
            if (resizeObserver !== null) {
                resizeObserver.disconnect();
            }
        }
    });
    return {
        applyLineClamp: applyLineClamp,
        resetLineClamp: resetLineClamp
    };
}
export { cssVariablesWatcher as c, makeLinesClampable as m };
