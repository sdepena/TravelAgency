var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-10623738.js';
var gaugeCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-gauge{--center-circle-text-color:rgba(44, 44, 44, 1);--center-circle-background-color:rgba(255, 255, 255, 0);--indicator-circle-background-color:rgba(44, 44, 44, 1);--value-text-color:rgba(44, 44, 44, 1);--value-text-background-color:rgba(255, 255, 255, 0.8);--max-value-background-color:rgba(255, 255, 255, 0.8);--max-value-text-color:rgba(40, 40, 40, 0.8);--min-value-background-color:rgba(255, 255, 255, 0.8);--min-value-text-color:rgba(40, 40, 40, 0.8);--indicator-line-background-color:rgba(44, 44, 44, 1);display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;-ms-flex-align:center;align-items:center;-ms-flex-wrap:wrap;flex-wrap:wrap;position:relative;width:100%}gx-gauge .gaugeContainerLine{position:relative;width:100%;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}gx-gauge .gaugeContainerLine .gauge{display:-ms-flexbox;display:flex}gx-gauge .gaugeContainerLine .gauge .marker{background-color:var(--value-text-background-color);color:var(--value-text-color)}gx-gauge .gaugeContainerLine .minMaxDisplay{z-index:1;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;width:100%}gx-gauge .gaugeContainerLine .minMaxDisplay .maxValue{background-color:var(--max-value-background-color);color:var(--max-value-text-color)}gx-gauge .gaugeContainerLine .minMaxDisplay .minValue{background-color:var(--min-value-background-color);color:var(--min-value-text-color)}gx-gauge .gaugeContainerLine .rangesContainer{overflow:hidden;position:absolute;width:calc(100%);background-color:rgba(0, 0, 0, 0.2)}gx-gauge .gaugeContainerLine .rangesContainer .range{height:100%;position:absolute;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .gaugeContainerLine span.marker{-webkit-transform:translateY(-4px);transform:translateY(-4px);position:absolute;z-index:1;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .gaugeContainerLine span.marker .indicator{content:\"\";border-left-style:solid;border-left-color:var(--indicator-line-background-color);display:block;background-color:var(--indicator-line-background-color)}gx-gauge .gaugeContainerLine .labelsContainerLine{width:calc(100%);height:calc(100%);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}gx-gauge .gaugeContainerLine .labelsContainerLine .rangeName{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;margin-top:1px;position:absolute;-webkit-filter:brightness(0.5);filter:brightness(0.5);-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .svgContainer{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;height:100%;width:100%;-ms-flex-align:center;align-items:center}gx-gauge .svgContainer svg{width:100%;height:100%}gx-gauge .svgContainer svg circle{-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .svgContainer .gauge{position:absolute;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center}gx-gauge .svgContainer .gauge div{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;color:var(--center-circle-text-color);background-color:var(--center-circle-background-color)}gx-gauge .svgContainer .gauge div span.current-value{font-weight:900}gx-gauge .circularMarker{width:100%;position:absolute;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .circularMarker .circularIndicator{background-color:var(--indicator-circle-background-color)}";
var Gauge = /** @class */ (function () {
    function Gauge(hostRef) {
        registerInstance(this, hostRef);
        this.gxGaugeDidLoad = createEvent(this, "gxGaugeDidLoad", 7);
        /**
         * This property allows selecting the gauge type. The allowed values are `circle` or `line` (defautl).
         */
        this.type = "line";
        /**
         *  Set `true` to display the current value. Default is `false`.
         *
         */
        this.showValue = false;
        /**
         *  Set `true` to display the minimum and maximum value. Default is `false`.
         *
         */
        this.showMinMax = false;
        /**
         * The minimum value of the gauge
         * 0 by Default
         */
        this.minValue = 0;
        /**
         * Allows specify the width of the circumference _(When gauge is circle type)_ or the width of the bar _(When gauge is Line type)_ in % relative the component size.
         *
         */
        this.thickness = 10;
        this.rangesChildren = [];
        this.maxValueAux = this.minValue;
        this.totalAmount = 0;
    }
    Gauge.prototype.onGaugeRangeDidLoad = function (_a) {
        var _this = this;
        var childRange = _a.detail;
        this.rangesChildren = __spreadArrays(this.rangesChildren, [childRange]);
        this.totalAmount += childRange.amount;
        // Possible improvement here. Check the approach applied in navbar.jsx line 103
        childRange.element.addEventListener("gxGaugeRangeDidUnload", function () {
            _this.rangesChildren = _this.rangesChildren.filter(function (elementToSave) { return elementToSave != childRange; });
            _this.totalAmount -= childRange.amount;
        });
        childRange.element.addEventListener("gxGaugeRangeDidUpdate", function () {
            var index = _this.rangesChildren.findIndex(function (elementFinding) { return elementFinding === childRange; });
            _this.rangesChildren.splice(index, 1, childRange);
            _this.totalAmount = 0;
            for (var _i = 0, _a = _this.rangesChildren; _i < _a.length; _i++) {
                var childInstance = _a[_i];
                _this.totalAmount += childInstance.amount;
            }
        });
    };
    // If maxValue is undefined, it defines the maxValue as the sum of the amounts plus minValue
    Gauge.prototype.updateMaxValueAux = function () {
        this.maxValueAux =
            this.maxValue === undefined
                ? this.minValue + this.totalAmount
                : this.maxValue;
    };
    Gauge.prototype.calcThickness = function () {
        return typeof this.thickness === "number" &&
            this.thickness > 0 &&
            this.thickness <= 100
            ? this.thickness / 5
            : 10;
    };
    Gauge.prototype.calcPercentage = function () {
        return this.value <= this.minValue
            ? 0
            : ((this.value - this.minValue) * 100) /
                (this.maxValueAux - this.minValue);
    };
    Gauge.prototype.addCircleRanges = function (_a, position, radius) {
        var amount = _a.amount, color = _a.color;
        var FULL_CIRCLE_RADIANS = 2 * Math.PI;
        var ROTATION_FIX = -90;
        var circleLength = FULL_CIRCLE_RADIANS * radius;
        var range = this.maxValueAux - this.minValue;
        var valuePercentage = amount / range;
        return (h("circle", { class: "circle-range", r: radius, cx: "50%", cy: "50%", stroke: color, "stroke-dasharray": circleLength * valuePercentage + ", " + circleLength, fill: "none", transform: "rotate(" + (position + ROTATION_FIX) + " 50,50)", "data-amount": amount, "stroke-width": this.thickness + "%" }));
    };
    Gauge.prototype.addLineRanges = function (_a, position) {
        var amount = _a.amount, color = _a.color;
        var range = this.maxValueAux - this.minValue;
        return (h("div", { class: "range", style: {
                "background-color": color,
                "margin-left": position + "%",
                width: (amount * 100) / range + "%"
            } }));
    };
    Gauge.prototype.addLineRangesLabels = function (_a, position) {
        var amount = _a.amount, color = _a.color, name = _a.name;
        var range = this.maxValueAux - this.minValue;
        return (h("span", { class: "rangeName", style: {
                "margin-left": position + "%",
                color: color,
                // transform: `translateY(-${this.thickness >= 7 ? 0 : 12 + this.thickness}px)`,
                transform: "translateY(" + (this.thickness >= 7
                    ? 0
                    : this.element.offsetHeight / 4 + this.thickness / 3) + "px)",
                width: (amount * 100) / range + "%"
            } }, name));
    };
    Gauge.prototype.renderCircle = function (childRanges) {
        var _this = this;
        var FULL_CIRCLE_RADIO = 100 / 2;
        var svgRanges = [];
        var ONE_PERCENT_OF_CIRCLE_DREGREE = 3.6;
        var radius = FULL_CIRCLE_RADIO - this.thickness / 2;
        var ROTATION_FIX = 90; // Used to correct the rotation
        this.totalAmount = 0;
        for (var i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        var range = this.maxValueAux - this.minValue;
        var positionInGauge = 0;
        for (var i = 0; i < childRanges.length; i++) {
            svgRanges.push(this.addCircleRanges(childRanges[i], positionInGauge, radius));
            positionInGauge += (360 * childRanges[i].amount) / range;
        }
        var rotation = this.calcPercentage() == 100
            ? "rotate(" + (359.5 + ROTATION_FIX) + "deg)"
            : "rotate(" + (this.calcPercentage() * ONE_PERCENT_OF_CIRCLE_DREGREE +
                ROTATION_FIX) + "deg)";
        if (this.showValue) {
            var ro = new ResizeObserver(function (entries) {
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var entry = entries_1[_i];
                    var elem = entry.contentRect;
                    var minimumSize = Math.min(elem.width, elem.height);
                    var value = _this.element.querySelector(".current-value");
                    var marker = _this.element.querySelector(".circularMarker");
                    var markerIndicator = _this.element.querySelector(".circularIndicator");
                    value.setAttribute("style", "font-size: " + minimumSize / 2.5 + "px");
                    marker.setAttribute("style", "transform: " + rotation + "; max-width: " + minimumSize + "px");
                    markerIndicator.setAttribute("style", "width: " + (_this.thickness + 2) + "%; height: " + minimumSize / 100 + "px");
                }
            });
            // Observe the gauge to resize the font and the value marker
            ro.observe(this.element);
        }
        return (h(Host, null, h("div", { class: "svgContainer" }, h("svg", { viewBox: "0 0 100 100" }, h("circle", { r: radius, cx: "50%", cy: "50%", stroke: "rgba(0, 0, 0, 0.2)", fill: "none", "stroke-width": this.thickness / 2 + "%" }), svgRanges), this.showValue && (h("div", { class: "gauge" }, h("div", null, this.showValue && (h("span", { class: "current-value" }, "" + this.value)))))), this.showValue && (h("div", { class: "circularMarker" }, h("div", { class: "circularIndicator" })))));
    };
    Gauge.prototype.renderLine = function (childRanges) {
        var divRanges = [];
        var divRangesName = [];
        this.totalAmount = 0;
        for (var i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        // Depending of `this.value`, it calculates how much the value marker has to move from the left side
        var valueOffset = this.value <= this.minValue
            ? 0
            : this.value >= this.maxValueAux
                ? 100
                : this.calcPercentage() >= 98
                    ? 72
                    : 50;
        var range = this.maxValueAux - this.minValue;
        var positionInGauge = 0;
        for (var i = 0; i < childRanges.length; i++) {
            divRanges.push(this.addLineRanges(childRanges[i], positionInGauge));
            divRangesName.push(this.addLineRangesLabels(childRanges[i], positionInGauge));
            positionInGauge += (100 * childRanges[i].amount) / range;
        }
        return (h("div", { class: "gaugeContainerLine", style: {
                height: 10 * this.calcThickness() + "px",
                "margin-top": (this.showValue || this.thickness < 7 ? 23.5 : 0) + "px",
                "margin-bottom": (this.showValue && this.thickness < 7 ? 22 : this.showMinMax ? 20 : 1) + "px"
            } }, h("div", { class: "gauge" }, this.showValue ? (h("span", { class: "marker", style: {
                "margin-left": (this.value <= this.minValue
                    ? 0
                    : this.value >= this.maxValueAux
                        ? 100
                        : this.calcPercentage()) + "%",
                transform: "translate(-" + valueOffset + "%, -28px)" // 22px, 38px
            } }, this.value)) : ("")), h("div", { class: "rangesContainer", style: {
                height: 2 * this.thickness + "px",
                "border-radius": this.thickness + "px"
            } }, divRanges), this.showValue ? (h("span", { class: "marker", style: {
                "margin-left": (this.calcPercentage() >= 100 ? 100 : this.calcPercentage()) + "%"
            } }, h("div", { class: "indicator", style: {
                height: this.thickness * 2 + 4 + "px",
                "border-left-width": this.element.offsetWidth /
                    document.body.offsetWidth + "vw",
                transform: this.calcPercentage() > 0 && this.calcPercentage() < 100
                    ? "translateX(-50%)"
                    : this.calcPercentage() >= 100
                        ? "translateX(-100%)"
                        : "translateX(0%)"
            } }))) : (""), h("div", { class: "labelsContainerLine" }, divRangesName), this.showMinMax ? (h("div", { class: "minMaxDisplay" }, h("span", { class: "minValue" }, this.minValue, h("span", null)), h("span", { class: "maxValue" }, this.maxValueAux, h("span", null)))) : ("")));
    };
    Gauge.prototype.render = function () {
        this.minimumSize =
            this.element.offsetHeight > this.element.offsetWidth
                ? this.element.offsetWidth
                : this.element.offsetHeight;
        var childRanges = Array.from(this.element.querySelectorAll("gx-gauge-range"));
        if (this.type === "circle") {
            return this.renderCircle(childRanges);
        }
        else if (this.type === "line") {
            return this.renderLine(childRanges);
        }
        else {
            // tslint:disable-next-line:no-console
            console.warn("Error rendering component. Invalid type of gauge in ", this.element);
        }
    };
    Object.defineProperty(Gauge.prototype, "element", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    return Gauge;
}());
Gauge.style = gaugeCss;
export { Gauge as gx_gauge };
