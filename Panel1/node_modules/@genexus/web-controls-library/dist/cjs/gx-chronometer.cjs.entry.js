'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index$1 = require('./index-4863abdd.js');

var TimerState;
(function (TimerState) {
    TimerState["Running"] = "running";
    TimerState["Stopped"] = "stopped";
    TimerState["Reset"] = "reset";
})(TimerState || (TimerState = {}));

const chronometerCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-chronometer{display:inline}gx-chronometer[hidden]{display:none !important}gx-chronometer[hidden][invisible-mode=keep-space]{display:inline !important;visibility:hidden}";

const Chronometer = class {
    constructor(hostRef) {
        index$1.registerInstance(this, hostRef);
        this.input = index$1.createEvent(this, "input", 7);
        this.change = index$1.createEvent(this, "change", 7);
        this.end = index$1.createEvent(this, "end", 7);
        this.tick = index$1.createEvent(this, "tick", 7);
        this.startedTime = 0;
        this.started = false;
        this.elapsedTime = 0;
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * When the chronometer reaches this value,
         * MaxValueText will be shown instead of the Chronometer value.
         */
        this.maxValue = 0;
        /**
         * Time unit: (s) seconds or (ms) milliseconds for every time control Property.
         */
        this.unit = "s";
        /**
         * Defines the interval that the function onTick will be called.
         */
        this.interval = 1;
        /**
         * State of the Chronometer.
         */
        this.state = TimerState.Stopped;
        /**
         * The value of the control.
         */
        this.value = 0;
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    async getNativeInputId() {
        return this.element;
    }
    componentWillLoad() {
        this.elapsedTime = this.value * this.getUnit();
    }
    componentDidUnload() {
        this.stop();
    }
    /**
     * Starts the Chronometer
     */
    async start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.startedTime = Date.now() - this.elapsedTime;
        this.updateElapsedTime();
        this.timer = window.setInterval(() => {
            this.updateElapsedTime();
            if (this.maxValue > 0 &&
                this.elapsedTime >= this.maxValue * this.getUnit()) {
                this.end.emit();
                this.stop();
            }
        }, 1000);
        if (this.interval > 0) {
            this.eventTimer = window.setInterval(() => {
                this.tickHandler();
            }, this.interval * this.getUnit());
        }
    }
    /**
     * Stops the Chronometer
     */
    async stop() {
        window.clearInterval(this.eventTimer);
        window.clearInterval(this.timer);
        this.started = false;
        this.startedTime = 0;
    }
    /**
     * Stops and set to 0 the Chronometer.
     */
    async reset() {
        this.stop();
        this.value = 0;
        this.startedTime = 0;
        this.elapsedTime = 0;
    }
    handleChange() {
        this.input.emit();
        this.change.emit();
    }
    tickHandler() {
        this.tick.emit();
    }
    stateChanged(newState, oldState) {
        if (oldState === newState) {
            return;
        }
        switch (newState) {
            case TimerState.Running:
                this.start();
                break;
            case TimerState.Stopped:
                this.stop();
                break;
            case TimerState.Reset:
                this.reset();
                break;
        }
    }
    getUnit() {
        return this.unit === "s" ? 1000 : 1;
    }
    updateElapsedTime() {
        this.elapsedTime = Date.now() - this.startedTime;
        this.value = Math.floor(this.elapsedTime / this.getUnit());
    }
    render() {
        const time = Math.floor(this.elapsedTime / 1000);
        const maxVal = this.maxValue * this.getUnit();
        const maxValueReached = this.elapsedTime > maxVal && maxVal !== 0;
        return index$1.h("span", null, maxValueReached ? this.maxValueText : time);
    }
    get element() { return index$1.getElement(this); }
    static get watchers() { return {
        "value": ["handleChange"],
        "state": ["stateChanged"]
    }; }
};
Chronometer.style = chronometerCss;

exports.gx_chronometer = Chronometer;
