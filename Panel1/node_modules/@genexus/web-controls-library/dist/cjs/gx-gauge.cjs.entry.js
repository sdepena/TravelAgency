'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index$1 = require('./index-4863abdd.js');

const gaugeCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-gauge{--center-circle-text-color:rgba(44, 44, 44, 1);--center-circle-background-color:rgba(255, 255, 255, 0);--indicator-circle-background-color:rgba(44, 44, 44, 1);--value-text-color:rgba(44, 44, 44, 1);--value-text-background-color:rgba(255, 255, 255, 0.8);--max-value-background-color:rgba(255, 255, 255, 0.8);--max-value-text-color:rgba(40, 40, 40, 0.8);--min-value-background-color:rgba(255, 255, 255, 0.8);--min-value-text-color:rgba(40, 40, 40, 0.8);--indicator-line-background-color:rgba(44, 44, 44, 1);display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;-ms-flex-align:center;align-items:center;-ms-flex-wrap:wrap;flex-wrap:wrap;position:relative;width:100%}gx-gauge .gaugeContainerLine{position:relative;width:100%;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}gx-gauge .gaugeContainerLine .gauge{display:-ms-flexbox;display:flex}gx-gauge .gaugeContainerLine .gauge .marker{background-color:var(--value-text-background-color);color:var(--value-text-color)}gx-gauge .gaugeContainerLine .minMaxDisplay{z-index:1;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;width:100%}gx-gauge .gaugeContainerLine .minMaxDisplay .maxValue{background-color:var(--max-value-background-color);color:var(--max-value-text-color)}gx-gauge .gaugeContainerLine .minMaxDisplay .minValue{background-color:var(--min-value-background-color);color:var(--min-value-text-color)}gx-gauge .gaugeContainerLine .rangesContainer{overflow:hidden;position:absolute;width:calc(100%);background-color:rgba(0, 0, 0, 0.2)}gx-gauge .gaugeContainerLine .rangesContainer .range{height:100%;position:absolute;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .gaugeContainerLine span.marker{-webkit-transform:translateY(-4px);transform:translateY(-4px);position:absolute;z-index:1;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .gaugeContainerLine span.marker .indicator{content:\"\";border-left-style:solid;border-left-color:var(--indicator-line-background-color);display:block;background-color:var(--indicator-line-background-color)}gx-gauge .gaugeContainerLine .labelsContainerLine{width:calc(100%);height:calc(100%);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}gx-gauge .gaugeContainerLine .labelsContainerLine .rangeName{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;margin-top:1px;position:absolute;-webkit-filter:brightness(0.5);filter:brightness(0.5);-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .svgContainer{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;height:100%;width:100%;-ms-flex-align:center;align-items:center}gx-gauge .svgContainer svg{width:100%;height:100%}gx-gauge .svgContainer svg circle{-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .svgContainer .gauge{position:absolute;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center}gx-gauge .svgContainer .gauge div{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;color:var(--center-circle-text-color);background-color:var(--center-circle-background-color)}gx-gauge .svgContainer .gauge div span.current-value{font-weight:900}gx-gauge .circularMarker{width:100%;position:absolute;-webkit-transition:0.3s ease;transition:0.3s ease}gx-gauge .circularMarker .circularIndicator{background-color:var(--indicator-circle-background-color)}";

const Gauge = class {
    constructor(hostRef) {
        index$1.registerInstance(this, hostRef);
        this.gxGaugeDidLoad = index$1.createEvent(this, "gxGaugeDidLoad", 7);
        /**
         * This property allows selecting the gauge type. The allowed values are `circle` or `line` (defautl).
         */
        this.type = "line";
        /**
         *  Set `true` to display the current value. Default is `false`.
         *
         */
        this.showValue = false;
        /**
         *  Set `true` to display the minimum and maximum value. Default is `false`.
         *
         */
        this.showMinMax = false;
        /**
         * The minimum value of the gauge
         * 0 by Default
         */
        this.minValue = 0;
        /**
         * Allows specify the width of the circumference _(When gauge is circle type)_ or the width of the bar _(When gauge is Line type)_ in % relative the component size.
         *
         */
        this.thickness = 10;
        this.rangesChildren = [];
        this.maxValueAux = this.minValue;
        this.totalAmount = 0;
    }
    onGaugeRangeDidLoad({ detail: childRange }) {
        this.rangesChildren = [...this.rangesChildren, childRange];
        this.totalAmount += childRange.amount;
        // Possible improvement here. Check the approach applied in navbar.jsx line 103
        childRange.element.addEventListener("gxGaugeRangeDidUnload", () => {
            this.rangesChildren = this.rangesChildren.filter(elementToSave => elementToSave != childRange);
            this.totalAmount -= childRange.amount;
        });
        childRange.element.addEventListener("gxGaugeRangeDidUpdate", () => {
            const index = this.rangesChildren.findIndex(elementFinding => elementFinding === childRange);
            this.rangesChildren.splice(index, 1, childRange);
            this.totalAmount = 0;
            for (const childInstance of this.rangesChildren) {
                this.totalAmount += childInstance.amount;
            }
        });
    }
    // If maxValue is undefined, it defines the maxValue as the sum of the amounts plus minValue
    updateMaxValueAux() {
        this.maxValueAux =
            this.maxValue === undefined
                ? this.minValue + this.totalAmount
                : this.maxValue;
    }
    calcThickness() {
        return typeof this.thickness === "number" &&
            this.thickness > 0 &&
            this.thickness <= 100
            ? this.thickness / 5
            : 10;
    }
    calcPercentage() {
        return this.value <= this.minValue
            ? 0
            : ((this.value - this.minValue) * 100) /
                (this.maxValueAux - this.minValue);
    }
    addCircleRanges({ amount, color }, position, radius) {
        const FULL_CIRCLE_RADIANS = 2 * Math.PI;
        const ROTATION_FIX = -90;
        const circleLength = FULL_CIRCLE_RADIANS * radius;
        const range = this.maxValueAux - this.minValue;
        const valuePercentage = amount / range;
        return (index$1.h("circle", { class: "circle-range", r: radius, cx: "50%", cy: "50%", stroke: color, "stroke-dasharray": `${circleLength * valuePercentage}, ${circleLength}`, fill: "none", transform: `rotate(${position + ROTATION_FIX} 50,50)`, "data-amount": amount, "stroke-width": `${this.thickness}%` }));
    }
    addLineRanges({ amount, color }, position) {
        const range = this.maxValueAux - this.minValue;
        return (index$1.h("div", { class: "range", style: {
                "background-color": color,
                "margin-left": `${position}%`,
                width: `${(amount * 100) / range}%`
            } }));
    }
    addLineRangesLabels({ amount, color, name }, position) {
        const range = this.maxValueAux - this.minValue;
        return (index$1.h("span", { class: "rangeName", style: {
                "margin-left": `${position}%`,
                color: color,
                // transform: `translateY(-${this.thickness >= 7 ? 0 : 12 + this.thickness}px)`,
                transform: `translateY(${this.thickness >= 7
                    ? 0
                    : this.element.offsetHeight / 4 + this.thickness / 3}px)`,
                width: `${(amount * 100) / range}%`
            } }, name));
    }
    renderCircle(childRanges) {
        const FULL_CIRCLE_RADIO = 100 / 2;
        const svgRanges = [];
        const ONE_PERCENT_OF_CIRCLE_DREGREE = 3.6;
        const radius = FULL_CIRCLE_RADIO - this.thickness / 2;
        const ROTATION_FIX = 90; // Used to correct the rotation
        this.totalAmount = 0;
        for (let i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        const range = this.maxValueAux - this.minValue;
        let positionInGauge = 0;
        for (let i = 0; i < childRanges.length; i++) {
            svgRanges.push(this.addCircleRanges(childRanges[i], positionInGauge, radius));
            positionInGauge += (360 * childRanges[i].amount) / range;
        }
        const rotation = this.calcPercentage() == 100
            ? `rotate(${359.5 + ROTATION_FIX}deg)`
            : `rotate(${this.calcPercentage() * ONE_PERCENT_OF_CIRCLE_DREGREE +
                ROTATION_FIX}deg)`;
        if (this.showValue) {
            const ro = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const elem = entry.contentRect;
                    const minimumSize = Math.min(elem.width, elem.height);
                    const value = this.element.querySelector(".current-value");
                    const marker = this.element.querySelector(".circularMarker");
                    const markerIndicator = this.element.querySelector(".circularIndicator");
                    value.setAttribute("style", `font-size: ${minimumSize / 2.5}px`);
                    marker.setAttribute("style", `transform: ${rotation}; max-width: ${minimumSize}px`);
                    markerIndicator.setAttribute("style", `width: ${this.thickness + 2}%; height: ${minimumSize / 100}px`);
                }
            });
            // Observe the gauge to resize the font and the value marker
            ro.observe(this.element);
        }
        return (index$1.h(index$1.Host, null, index$1.h("div", { class: "svgContainer" }, index$1.h("svg", { viewBox: "0 0 100 100" }, index$1.h("circle", { r: radius, cx: "50%", cy: "50%", stroke: "rgba(0, 0, 0, 0.2)", fill: "none", "stroke-width": `${this.thickness / 2}%` }), svgRanges), this.showValue && (index$1.h("div", { class: "gauge" }, index$1.h("div", null, this.showValue && (index$1.h("span", { class: "current-value" }, `${this.value}`)))))), this.showValue && (index$1.h("div", { class: "circularMarker" }, index$1.h("div", { class: "circularIndicator" })))));
    }
    renderLine(childRanges) {
        const divRanges = [];
        const divRangesName = [];
        this.totalAmount = 0;
        for (let i = childRanges.length - 1; i >= 0; i--) {
            this.totalAmount += childRanges[i].amount;
        }
        this.updateMaxValueAux();
        // Depending of `this.value`, it calculates how much the value marker has to move from the left side
        const valueOffset = this.value <= this.minValue
            ? 0
            : this.value >= this.maxValueAux
                ? 100
                : this.calcPercentage() >= 98
                    ? 72
                    : 50;
        const range = this.maxValueAux - this.minValue;
        let positionInGauge = 0;
        for (let i = 0; i < childRanges.length; i++) {
            divRanges.push(this.addLineRanges(childRanges[i], positionInGauge));
            divRangesName.push(this.addLineRangesLabels(childRanges[i], positionInGauge));
            positionInGauge += (100 * childRanges[i].amount) / range;
        }
        return (index$1.h("div", { class: "gaugeContainerLine", style: {
                height: `${10 * this.calcThickness()}px`,
                "margin-top": `${this.showValue || this.thickness < 7 ? 23.5 : 0}px`,
                "margin-bottom": `${this.showValue && this.thickness < 7 ? 22 : this.showMinMax ? 20 : 1}px`
            } }, index$1.h("div", { class: "gauge" }, this.showValue ? (index$1.h("span", { class: "marker", style: {
                "margin-left": `${this.value <= this.minValue
                    ? 0
                    : this.value >= this.maxValueAux
                        ? 100
                        : this.calcPercentage()}%`,
                transform: `translate(-${valueOffset}%, -28px)` // 22px, 38px
            } }, this.value)) : ("")), index$1.h("div", { class: "rangesContainer", style: {
                height: `${2 * this.thickness}px`,
                "border-radius": `${this.thickness}px`
            } }, divRanges), this.showValue ? (index$1.h("span", { class: "marker", style: {
                "margin-left": `${this.calcPercentage() >= 100 ? 100 : this.calcPercentage()}%`
            } }, index$1.h("div", { class: "indicator", style: {
                height: `${this.thickness * 2 + 4}px`,
                "border-left-width": `${this.element.offsetWidth /
                    document.body.offsetWidth}vw`,
                transform: this.calcPercentage() > 0 && this.calcPercentage() < 100
                    ? "translateX(-50%)"
                    : this.calcPercentage() >= 100
                        ? "translateX(-100%)"
                        : "translateX(0%)"
            } }))) : (""), index$1.h("div", { class: "labelsContainerLine" }, divRangesName), this.showMinMax ? (index$1.h("div", { class: "minMaxDisplay" }, index$1.h("span", { class: "minValue" }, this.minValue, index$1.h("span", null)), index$1.h("span", { class: "maxValue" }, this.maxValueAux, index$1.h("span", null)))) : ("")));
    }
    render() {
        this.minimumSize =
            this.element.offsetHeight > this.element.offsetWidth
                ? this.element.offsetWidth
                : this.element.offsetHeight;
        const childRanges = Array.from(this.element.querySelectorAll("gx-gauge-range"));
        if (this.type === "circle") {
            return this.renderCircle(childRanges);
        }
        else if (this.type === "line") {
            return this.renderLine(childRanges);
        }
        else {
            // tslint:disable-next-line:no-console
            console.warn("Error rendering component. Invalid type of gauge in ", this.element);
        }
    }
    get element() { return index$1.getElement(this); }
};
Gauge.style = gaugeCss;

exports.gx_gauge = Gauge;
