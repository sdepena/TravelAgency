function debounce(func, wait, immediate = false) {
    let timeout;
    return function (...args) {
        const later = function () {
            timeout = null;
            if (!immediate) {
                func.apply(this, args);
            }
        }.bind(this);
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(this, args);
        }
    };
}
function overrideMethod(component, methodName, { before, after }) {
    const oldMethod = component[methodName];
    component[methodName] = () => {
        if (before !== undefined) {
            before();
        }
        if (oldMethod !== undefined) {
            oldMethod.call(component);
        }
        if (after !== undefined) {
            after();
        }
    };
}

function cssVariablesWatcher(component, properties) {
    const updatePropertiesFromCss = debounce(function () {
        for (const prop of properties) {
            const propCssValue = getComputedStyle(component.element)
                .getPropertyValue(prop.cssVariableName)
                .trim();
            if (propCssValue && component[prop.propertyName] !== propCssValue) {
                component[prop.propertyName] = propCssValue;
            }
        }
    }, 100);
    // Set up a MutationObserver to monitor changes on style and class attributes.
    // When a change occurs on this attributes, the properties listed in
    // properties are updated with their corresponding CSS variables values.
    // The properties will be kept in sync with the CSS variables values.
    // The properties must have the mutable flag set to true.
    const classObserver = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
            if (mutation.type === "attributes" &&
                (mutation.attributeName === "class" ||
                    mutation.attributeName === "style")) {
                updatePropertiesFromCss();
            }
        }
    });
    // componentDidLoad, componentDidUpdate and componentDidUnload are overriden
    // to start and end observing the mutations, and to update the properties values.
    overrideMethod(component, "componentDidLoad", {
        after: () => updatePropertiesFromCss(),
        before: () => {
            classObserver.observe(component.element, {
                attributes: true,
                childList: false,
                subtree: false
            });
        }
    });
    overrideMethod(component, "componentDidUpdate", {
        after: () => updatePropertiesFromCss()
    });
    overrideMethod(component, "componentDidUnload", {
        before: () => classObserver.disconnect()
    });
}

const LINE_HEIGHT_CLAMP_THRESHOLD = 0.3;
function makeLinesClampable(component, contentElementSelect, lineMeasuringElementSelector) {
    const applyLineClamp = debounce(function () {
        requestAnimationFrame(function applyLineClampImpl() {
            const contentElement = component.element.querySelector(contentElementSelect);
            const lineMeasuringElement = component.element.querySelector(lineMeasuringElementSelector);
            if (contentElement === null || lineMeasuringElement === null) {
                return;
            }
            const { offsetHeight, scrollHeight } = contentElement;
            const delta = scrollHeight - offsetHeight;
            const lineHeight = lineMeasuringElement.clientHeight;
            if (delta > lineHeight * LINE_HEIGHT_CLAMP_THRESHOLD) {
                component.maxLines = Math.trunc(offsetHeight / lineHeight);
                component.maxHeight = component.maxLines * lineHeight;
            }
        });
    }, 100);
    const resetLineClamp = function resetLineClampImpl() {
        component.maxLines = 0;
    };
    let resizeObserver = null;
    overrideMethod(component, "componentDidLoad", {
        before: () => {
            if (component.lineClamp) {
                resizeObserver = new ResizeObserver(() => {
                    // If the component resizes, we reset the clamping and wait after the next paint to calculate sizes again
                    // to check if clamping is needed
                    resetLineClamp();
                    applyLineClamp();
                });
                resizeObserver.observe(component.element);
            }
        }
    });
    overrideMethod(component, "componentDidRender", {
        before: () => {
            if (component.lineClamp) {
                applyLineClamp();
            }
        }
    });
    overrideMethod(component, "disconnectedCallback", {
        before: () => {
            if (resizeObserver !== null) {
                resizeObserver.disconnect();
            }
        }
    });
    return {
        applyLineClamp,
        resetLineClamp
    };
}

export { cssVariablesWatcher as c, makeLinesClampable as m };
