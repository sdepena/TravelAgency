import { h, r as registerInstance, c as createEvent, H as Host, g as getElement } from './index-10623738.js';
import { m as makeHighlightable } from './highlightable-49b186e7.js';
import { c as cssVariablesWatcher, m as makeLinesClampable } from './line-clamp-165ccce6.js';

let autoEditId = 0;
const fontCategoryTagMap = {
    body: "p",
    caption1: "span",
    caption2: "span",
    footnote: "footer",
    headline: "h1",
    subheadline: "h2"
};
class EditRender {
    constructor(component, handlers) {
        this.component = component;
        this.handleChange = handlers.handleChange;
        this.handleTriggerClick = handlers.handleTriggerClick;
        this.handleValueChanging = handlers.handleValueChanging;
    }
    getNativeInputId() {
        return this.getNativeInput().id;
    }
    getNativeInput() {
        return this.component.element.querySelector("[data-native-element]");
    }
    getCssClasses() {
        const edit = this.component;
        const classList = [];
        if (edit.type === "file") {
            classList.push("form-control-file");
        }
        else {
            classList.push("form-control");
        }
        return classList.join(" ");
    }
    getTriggerCssClasses() {
        const classList = [];
        classList.push("btn");
        classList.push("btn-outline-secondary");
        return classList.join(" ");
    }
    getValueFromEvent(event) {
        return event.target && event.target.value;
    }
    stopPropagation(event) {
        event.stopPropagation();
    }
    getReadonlyContent(component, initialContent) {
        let content = initialContent;
        if (content &&
            (component.type === "datetime-local" || component.type === "date")) {
            const dateTime = new Date(component.value);
            if (component.type === "date") {
                dateTime.setDate(dateTime.getDate() + 1);
            }
            const dayMonthYear = new Intl.DateTimeFormat("default", {
                year: "numeric",
                month: "numeric",
                day: "numeric"
            }).format(dateTime);
            if (component.type === "date") {
                content = `${dayMonthYear}`;
            }
            else {
                const hourMins = new Intl.DateTimeFormat("default", {
                    hour: "numeric",
                    minute: "numeric"
                }).format(dateTime);
                content = `${dayMonthYear} ${hourMins}`;
            }
        }
        return content;
    }
    /**
     * Update the native input element when the value changes
     */
    valueChanged() {
        const inputEl = this.getNativeInput();
        if (inputEl && inputEl.value !== this.component.value) {
            inputEl.value = this.component.value;
        }
    }
    render(slots) {
        const edit = this.component;
        const valueChangingHandler = this.handleValueChanging;
        if (!this.inputId) {
            this.inputId = edit.element.id
                ? `${edit.element.id}__edit`
                : `gx-edit-auto-id-${autoEditId++}`;
        }
        const attris = {
            "aria-disabled": edit.disabled ? "true" : undefined,
            autocapitalize: edit.autocapitalize,
            autocomplete: edit.autocomplete,
            autocorrect: edit.autocorrect,
            class: this.getCssClasses(),
            "data-native-element": "",
            disabled: edit.disabled,
            hidden: edit.readonly,
            id: this.inputId,
            onChange: this.handleChange,
            onInput: valueChangingHandler,
            onClick: edit.disabled ? null : this.stopPropagation,
            placeholder: edit.placeholder
        };
        let editableElement;
        if (edit.multiline) {
            editableElement = h("textarea", Object.assign({}, attris), edit.value);
        }
        else {
            const input = h("input", Object.assign({}, attris, { type: edit.type, value: edit.value }));
            if (edit.showTrigger) {
                const existSlotContent = edit.element.querySelector("[slot='trigger-content']");
                editableElement = (h("div", { class: "input-group", hidden: edit.readonly },
                    input,
                    h("div", { class: "input-group-append" },
                        h("button", { class: this.getTriggerCssClasses(), onClick: this.handleTriggerClick, type: "button", disabled: edit.disabled, "aria-label": edit.triggerText }, existSlotContent !== null
                            ? slots.triggerContent
                            : edit.triggerText))));
            }
            else {
                editableElement = input;
            }
        }
        const ReadonlyTag = this.getReadonlyTagByFontCategory();
        return [
            h("gx-bootstrap", null),
            h(ReadonlyTag, { key: "readonly", hidden: !edit.readonly, "data-readonly": "", class: {
                    "gx-line-clamp": this.shouldClampLines()
                }, style: this.shouldClampLines() && {
                    "--max-lines": edit.maxLines.toString(),
                    "--max-height": `${edit.maxHeight}px`
                } },
                edit.lineClamp && (h("div", { class: "line-measuring", "aria-hidden": true }, "A")),
                this.getReadonlyContent(edit, edit.value)),
            editableElement
        ];
    }
    getReadonlyTagByFontCategory() {
        const tag = fontCategoryTagMap[this.component.fontCategory];
        if (!tag) {
            return "span";
        }
        return tag;
    }
    shouldClampLines() {
        return this.component.lineClamp && this.component.maxLines > 0;
    }
}

const editCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-edit [data-native-element]{margin-top:var(--margin-top, 0);margin-bottom:var(--margin-bottom, 0);height:unset}gx-edit [data-native-element]:focus{-webkit-box-shadow:none;box-shadow:none}gx-edit:not([show-trigger]) [slot=trigger-content],gx-edit[show-trigger=false] [slot=trigger-content]{display:none}gx-edit:not([show-trigger]) [data-native-element],gx-edit[show-trigger=false] [data-native-element]{margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0)}gx-edit[show-trigger] .input-group,gx-edit[show-trigger=true] .input-group{margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0)}gx-edit [data-readonly]{margin:0;margin-right:var(--margin-right, 0);margin-left:var(--margin-left, 0);margin-top:var(--margin-top, 0);margin-bottom:var(--margin-bottom, 0);padding:0;line-height:1.2;white-space:break-spaces;-ms-flex:1;flex:1}gx-edit h1,gx-edit h2,gx-edit footer{font-size:inherit;font-weight:inherit}gx-table-cell[align=center]>gx-edit,gx-table-cell[align=right]>gx-edit{-ms-flex-preferred-size:auto;flex-basis:auto;-ms-flex-positive:0;flex-grow:0}gx-edit{display:-ms-flexbox;display:flex;-ms-flex-align:stretch;align-items:stretch;-ms-flex:1;flex:1}gx-edit[hidden]{display:none !important}gx-edit[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}gx-edit.gx-edit--single-line [data-readonly]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}";

const Edit = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.change = createEvent(this, "change", 7);
        this.input = createEvent(this, "input", 7);
        this.gxTriggerClick = createEvent(this, "gxTriggerClick", 7);
        /**
         * Used to define the semantic of the element when readonly=true.
         *
         * Font categories are mapped to semantic HTML elements when rendered:
         *
         * * `"headline"`: `h1`
         * * `"subheadline"`: `h2`
         * * `"body"`: `p`
         * * `"footnote"`: `footer`
         * * `"caption1"`: `span`
         * * `"caption2"`: `span`
         */
        this.fontCategory = "body";
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        /**
         * This attribute lets you specify if the element is disabled.
         * If disabled, it will not fire any user interaction related event
         * (for example, click event).
         */
        this.disabled = false;
        /**
         * True to cut text when it overflows, showing an ellipsis (only applies when readonly)
         */
        this.lineClamp = false;
        /**
         * The type of control to render. A subset of the types supported by the `input` element is supported:
         *
         * * `"date"`
         * * `"datetime-local"`
         * * `"email"`
         * * `"file"`
         * * `"number"`
         * * `"password"`
         * * `"search"`
         * * `"tel"`
         * * `"text"`
         * * `"url"`
         */
        this.type = "text";
        /**
         * True to highlight control when an action is fired.
         */
        this.highlightable = false;
        this.maxLines = 0;
        this.maxHeight = 0;
        this.renderer = new EditRender(this, {
            handleChange: this.handleChange.bind(this),
            handleTriggerClick: this.handleTriggerClick.bind(this),
            handleValueChanging: this.handleValueChanging.bind(this)
        });
        cssVariablesWatcher(this, [
            {
                cssVariableName: "--font-category",
                propertyName: "fontCategory"
            }
        ]);
        makeLinesClampable(this, "[data-readonly]", ".line-measuring");
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    async getNativeInputId() {
        return this.renderer.getNativeInputId();
    }
    componentDidLoad() {
        this.toggleValueSetClass();
        if (this.readonly) {
            makeHighlightable(this);
        }
    }
    valueChanged() {
        this.renderer.valueChanged();
        this.toggleValueSetClass();
    }
    toggleValueSetClass() {
        if (this.value === "") {
            this.element.classList.remove("value-set");
        }
        else {
            this.element.classList.add("value-set");
        }
    }
    handleChange(event) {
        this.value = this.renderer.getValueFromEvent(event);
        this.change.emit(event);
    }
    handleValueChanging(event) {
        this.value = this.renderer.getValueFromEvent(event);
        this.input.emit(event);
    }
    handleTriggerClick(event) {
        if (!this.disabled) {
            event.stopPropagation();
        }
        this.gxTriggerClick.emit(event);
    }
    render() {
        return (h(Host, { class: {
                "gx-edit--single-line": this.type === "date" || this.type === "datetime-local"
            } }, this.renderer.render({
            triggerContent: h("slot", { name: "trigger-content" })
        })));
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueChanged"]
    }; }
};
Edit.style = editCss;

let autoFormFieldId = 0;
class FormFieldRender {
    constructor(component) {
        this.component = component;
        this.LABEL_WIDTH_BY_POSITION = {
            bottom: "label-bottom",
            float: "",
            left: "label-left",
            none: "sr-only",
            right: "label-right",
            top: "label-top"
        };
        this.INNER_CONTROL_WIDTH_BY_LABEL_POSITION = {
            bottom: "field-label-bottom",
            float: "",
            left: "field-label-left",
            none: "field-label-top",
            right: "field-label-right",
            top: "field-label-top"
        };
    }
    getLabelCssClass() {
        const classList = [];
        classList.push(this.LABEL_WIDTH_BY_POSITION[this.component.labelPosition]);
        if (this.component.labelPosition !== "float") {
            classList.push("col-form-label");
        }
        return classList.join(" ");
    }
    getInnerControlContainerClass() {
        const className = this.INNER_CONTROL_WIDTH_BY_LABEL_POSITION[this.component.labelPosition];
        return {
            [className]: true,
            "d-flex": true
        };
    }
    shouldRenderLabelBefore() {
        const formField = this.component;
        return (!formField.labelPosition ||
            formField.labelPosition === "top" ||
            formField.labelPosition === "right" ||
            formField.labelPosition === "bottom" ||
            formField.labelPosition === "left" ||
            formField.labelPosition === "none");
    }
    async componentDidLoad() {
        const formField = this.component;
        const innerControl = formField.element.querySelector("[area='field']");
        if (innerControl && innerControl.getNativeInputId) {
            const nativeInputId = await innerControl.getNativeInputId();
            if (nativeInputId) {
                const nativeInput = formField.element.querySelector(`#${nativeInputId}`);
                if (nativeInput !== null) {
                    nativeInput.setAttribute("data-part", "field");
                }
                const innerLabel = formField.element.querySelector("label");
                if (nativeInputId && innerLabel) {
                    innerLabel.setAttribute("for", nativeInputId);
                }
            }
        }
    }
    renderForRadio(renderLabel, renderLabelBefore, slot) {
        const labelId = `${this.formFieldId}-label`;
        const label = (h("div", { class: this.getLabelCssClass(), id: labelId, "data-part": "label" },
            h("div", { class: "label-content" }, this.component.labelCaption)));
        const labelPositionClassName = `label-position-${this.component.labelPosition}`;
        const isValidLabelPosition = this.component.labelPosition === "top" ||
            this.component.labelPosition === "right" ||
            this.component.labelPosition === "bottom" ||
            this.component.labelPosition === "left";
        return (h("div", { class: "form-group mb-0", "aria-labelledby": labelId, role: "group" },
            h("div", { class: {
                    "radio-group": true,
                    "no-gutters": true,
                    [labelPositionClassName]: isValidLabelPosition
                } },
                renderLabel && renderLabelBefore ? label : null,
                h("div", { class: this.getInnerControlContainerClass() }, slot),
                renderLabel && !renderLabelBefore ? label : null)));
    }
    render(slots) {
        const formField = this.component;
        const isRadioGroup = formField.element.querySelector("gx-radio-group[area='field']") !== null;
        const renderLabelBefore = this.shouldRenderLabelBefore();
        const renderLabel = formField.labelPosition !== "none";
        if (!this.formFieldId) {
            this.formFieldId =
                formField.element.id || `gx-form-field-auto-id-${autoFormFieldId++}`;
        }
        if (isRadioGroup) {
            return this.renderForRadio(renderLabel, renderLabelBefore, slots.default);
        }
        else {
            const label = (h("label", { class: this.getLabelCssClass(), "data-part": "label" },
                h("div", { class: "label-content" }, formField.labelCaption)));
            const result = formField.labelPosition === "float" ? (h("div", null,
                slots.default,
                label)) : (h("div", { class: {
                    "form-group": true,
                    "no-gutters": true,
                    "mb-0": true,
                    "flex-column": formField.labelPosition === "top",
                    "flex-column-reverse": formField.labelPosition === "bottom",
                    "flex-row-reverse": formField.labelPosition === "right",
                    "flex-row": formField.labelPosition === "left"
                } },
                renderLabel && renderLabelBefore ? label : null,
                h("div", { class: this.getInnerControlContainerClass() }, slots.default),
                renderLabel && !renderLabelBefore ? label : null));
            return [h("gx-bootstrap", null), result];
        }
    }
}

const formFieldCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-form-field{--elevation:0}gx-form-field [data-part=field]{-webkit-box-shadow:0 calc(var(--elevation) * 0.125rem) calc(var(--elevation) * 0.25rem) rgba(0, 0, 0, calc(var(--elevation) * 0.075));box-shadow:0 calc(var(--elevation) * 0.125rem) calc(var(--elevation) * 0.25rem) rgba(0, 0, 0, calc(var(--elevation) * 0.075))}gx-form-field[label-position=float]>div{position:relative;margin-bottom:1em;--input-padding-y:0.4em;--input-padding-x:0.7rem}gx-form-field[label-position=float]>div input,gx-form-field[label-position=float]>div>label{padding:var(--input-padding-y) var(--input-padding-x)}gx-form-field[label-position=float]>div>label{position:absolute;top:0;left:0;display:block;width:100%;margin-bottom:0;line-height:1.5;color:#495057;border:1px solid transparent;border-radius:0.25em;-webkit-transition:all 0.1s ease-in-out;transition:all 0.1s ease-in-out}gx-form-field[label-position=float]>div input::-webkit-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input:-ms-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input::-ms-input-placeholder{color:transparent}gx-form-field[label-position=float]>div input::-moz-placeholder{color:transparent}gx-form-field[label-position=float]>div input::placeholder{color:transparent}gx-form-field[label-position=float]>div [area=field].value-set input{padding-top:calc( var(--input-padding-y) + var(--input-padding-y) * (2 / 3) );padding-bottom:calc(var(--input-padding-y) / 3)}gx-form-field[label-position=float]>div [area=field].value-set~label{padding-top:calc(var(--input-padding-y) / 3);padding-bottom:calc(var(--input-padding-y) / 3);font-size:12px;color:#777}gx-form-field .label-position-top{-ms-flex-direction:column;flex-direction:column}gx-form-field .label-position-right{-ms-flex-direction:row-reverse;flex-direction:row-reverse}gx-form-field .label-position-bottom{-ms-flex-direction:column-reverse;flex-direction:column-reverse}gx-form-field .label-position-left{-ms-flex-direction:row;flex-direction:row}gx-form-field .label-left,gx-form-field .label-right{position:relative;width:100%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}gx-form-field .label-right{text-align:right}gx-form-field .label-top,gx-form-field .label-bottom,gx-form-field .field-label-top,gx-form-field .field-label-bottom{position:relative;width:100%;max-width:100%}gx-form-field .label-top,gx-form-field .label-bottom{-ms-flex:0;flex:0}gx-form-field .field-label-top,gx-form-field .field-label-bottom{-ms-flex:1;flex:1}gx-form-field .field-label-left,gx-form-field .field-label-right{position:relative;width:100%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}gx-form-field .label-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}gx-form-field>.form-group{max-height:100%;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-wrap:nowrap;flex-wrap:nowrap}gx-form-field>.form-group>div{-ms-flex:1;flex:1;max-height:100%}gx-form-field .radio-group{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-wrap:wrap;flex-wrap:wrap}gx-form-field gx-checkbox .custom-checkbox{padding-top:calc(1.375rem + 1px);padding-left:0.75rem}gx-form-field gx-checkbox .custom-control-label:before,gx-form-field gx-checkbox .custom-control-label:after{top:calc(0.25em - 15px)}gx-form-field gx-radio-option .custom-radio{padding-top:calc(0.375em + 1px)}gx-form-field gx-radio-option .custom-control-label:before,gx-form-field gx-radio-option .custom-control-label:after{top:calc(-0.15em + 7px)}gx-table-cell[align=center]>gx-form-field .label-left,gx-table-cell[align=center]>gx-form-field .label-right,gx-table-cell[align=center]>gx-form-field .field-label-left,gx-table-cell[align=center]>gx-form-field .field-label-right,gx-table-cell[align=right]>gx-form-field .label-left,gx-table-cell[align=right]>gx-form-field .label-right,gx-table-cell[align=right]>gx-form-field .field-label-left,gx-table-cell[align=right]>gx-form-field .field-label-right{-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}gx-form-field{display:-ms-flexbox;display:flex;justify-self:stretch;-ms-flex-item-align:stretch;align-self:stretch;-ms-flex:1;flex:1}gx-form-field[hidden]{display:none !important}gx-form-field[hidden][invisible-mode=keep-space]{display:-ms-flexbox !important;display:flex !important;visibility:hidden}[align=center]>gx-form-field [data-part=field],[align=center]>gx-form-field [data-readonly]{text-align:center}[align=right]>gx-form-field [data-part=field],[align=right]>gx-form-field [data-readonly]{text-align:right}[valign=middle]>gx-form-field [data-readonly],[valign=middle]>gx-form-field [data-part=label]{-ms-flex-item-align:center;align-self:center}[valign=bottom]>gx-form-field [data-readonly]{-ms-flex-item-align:end;align-self:flex-end;line-height:1.25}[valign=bottom]>gx-form-field [data-part=label]{-ms-flex-item-align:end;align-self:flex-end}";

const FormField = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        this.renderer = new FormFieldRender(this);
    }
    componentDidLoad() {
        this.renderer.componentDidLoad();
    }
    render() {
        return this.renderer.render({ default: h("slot", null) });
    }
    get element() { return getElement(this); }
};
FormField.style = formFieldCss;

export { Edit as gx_edit, FormField as gx_form_field };
