import { h, r as registerInstance, c as createEvent, H as Host, g as getElement } from './index-10623738.js';

let autoCheckBoxId = 0;
class SwitchRender {
    constructor(component) {
        this.component = component;
    }
    getNativeInputId() {
        return this.getNativeInput().id;
    }
    getNativeInput() {
        return this.component.element.querySelector("[data-native-element]");
    }
    getValueFromEvent(event) {
        return event.target && event.target.checked;
    }
    handleChange(event) {
        this.component.checked = this.getValueFromEvent(event);
        this.component.input.emit(event);
    }
    /**
     * Update the native input element when the value changes
     */
    checkedChanged() {
        const inputEl = this.getNativeInput();
        if (inputEl && inputEl.checked !== this.component.checked) {
            inputEl.checked = this.component.checked;
        }
    }
    render() {
        const switchCmp = this.component;
        if (!this.inputId) {
            this.inputId = switchCmp.element.id
                ? `${switchCmp.element.id}_checkbox`
                : `gx-checkbox-auto-id-${autoCheckBoxId++}`;
        }
        const inputAttrs = {
            "aria-checked": switchCmp.checked ? "true" : "false",
            "aria-disabled": switchCmp.disabled ? "true" : "false",
            checked: switchCmp.checked,
            class: "switch",
            "data-native-element": "",
            disabled: switchCmp.disabled,
            id: this.inputId,
            onChange: this.handleChange.bind(this),
            type: "checkbox"
        };
        return [
            h("gx-bootstrap", null),
            h("span", { class: "switch switch-sm" },
                h("input", Object.assign({}, inputAttrs)),
                h("label", { htmlFor: this.inputId }, switchCmp.caption))
        ];
    }
}

const switchCss = ".gx-line-clamp{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:var(--max-lines);overflow:hidden;max-height:var(--max-height)}.line-measuring{visibility:hidden;position:absolute}gx-switch{display:block}gx-switch[hidden]{display:none !important}gx-switch[hidden][invisible-mode=keep-space]{display:block !important;visibility:hidden}gx-switch .switch{font-size:1rem;position:relative}gx-switch .switch input{position:absolute;height:1px;width:1px;background:none;border:0;clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);overflow:hidden;padding:0}gx-switch .switch input+label{position:relative;min-width:calc(calc(2.375rem * 0.8) * 2);border-radius:calc(2.375rem * 0.8);height:calc(2.375rem * 0.8);line-height:calc(2.375rem * 0.8);display:inline-block;cursor:pointer;outline:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;text-indent:calc(calc(calc(2.375rem * 0.8) * 2) + 0.5rem)}gx-switch .switch input+label::before,gx-switch .switch input+label::after{content:\"\";position:absolute;top:0;left:0;width:calc(calc(2.375rem * 0.8) * 2);bottom:0;display:block}gx-switch .switch input+label::before{right:0;background-color:#dee2e6;border-radius:calc(2.375rem * 0.8);-webkit-transition:0.2s all;transition:0.2s all}gx-switch .switch input+label::after{top:2px;left:2px;width:calc(calc(2.375rem * 0.8) - calc(2px * 2));height:calc(calc(2.375rem * 0.8) - calc(2px * 2));border-radius:50%;background-color:white;-webkit-transition:0.2s all;transition:0.2s all}gx-switch .switch input:checked+label::before{background-color:#08d}gx-switch .switch input:checked+label::after{margin-left:calc(2.375rem * 0.8)}gx-switch .switch input:focus+label::before{outline:none;-webkit-box-shadow:0 0 0 0.2rem rgba(0, 136, 221, 0.25);box-shadow:0 0 0 0.2rem rgba(0, 136, 221, 0.25)}gx-switch .switch input:disabled+label{color:#868e96;cursor:not-allowed}gx-switch .switch input:disabled+label::before{background-color:#e9ecef}gx-switch .switch.switch-sm{font-size:0.875rem}gx-switch .switch.switch-sm input+label{min-width:calc(calc(1.9375rem * 0.8) * 2);height:calc(1.9375rem * 0.8);line-height:calc(1.9375rem * 0.8);text-indent:calc(calc(calc(1.9375rem * 0.8) * 2) + 0.5rem)}gx-switch .switch.switch-sm input+label::before{width:calc(calc(1.9375rem * 0.8) * 2)}gx-switch .switch.switch-sm input+label::after{width:calc(calc(1.9375rem * 0.8) - calc(2px * 2));height:calc(calc(1.9375rem * 0.8) - calc(2px * 2))}gx-switch .switch.switch-sm input:checked+label::after{margin-left:calc(1.9375rem * 0.8)}";

const Switch = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.input = createEvent(this, "input", 7);
        /**
         * This attribute allows you specify if the element is disabled.
         * If disabled, it will not trigger any user interaction related event
         * (for example, click event).
         */
        this.disabled = false;
        /**
         * This attribute lets you specify how this element will behave when hidden.
         *
         * | Value        | Details                                                                     |
         * | ------------ | --------------------------------------------------------------------------- |
         * | `keep-space` | The element remains in the document flow, and it does occupy space.         |
         * | `collapse`   | The element is removed form the document flow, and it doesn't occupy space. |
         */
        this.invisibleMode = "collapse";
        this.renderer = new SwitchRender(this);
    }
    /**
     * Returns the id of the inner `input` element (if set).
     */
    async getNativeInputId() {
        return this.renderer.getNativeInputId();
    }
    checkedChanged() {
        this.renderer.checkedChanged();
    }
    render() {
        return h(Host, { role: "switch" }, this.renderer.render());
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "checked": ["checkedChanged"]
    }; }
};
Switch.style = switchCss;

export { Switch as gx_switch };
